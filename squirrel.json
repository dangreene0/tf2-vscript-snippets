{
	///// BEGIN TF2 VScript Snippets /////
	"void AddAttribute(string, float, float)": {
		"prefix": "AddAttribute",
		"body": [
			"AddAttribute(${1:string}, ${2:float}, ${3:float})$0"
		],
		"description": "Add an attribute to the entity"
	},
	"void AddBotAttribute(int)": {
		"prefix": "AddBotAttribute",
		"body": [
			"AddBotAttribute(${1:int})$0"
		],
		"description": "Sets attribute flags on this TFBot"
	},
	"void AddBotTag(string)": {
		"prefix": "AddBotTag",
		"body": [
			"AddBotTag(${1:string})$0"
		],
		"description": "Adds a bot tag"
	},
	"void AddBroadcastTeamTarget(int)": {
		"prefix": "AddBroadcastTeamTarget",
		"body": [
			"AddBroadcastTeamTarget(${1:int})$0"
		],
		"description": "Adds a team (by index) to the broadcast list"
	},
	"void AddCond(ETFCond cond)": {
		"prefix": "AddCond",
		"body": [
			"AddCond(${1:ETFCond cond})$0"
		],
		"description": ""
	},
	"void AddCondEx(ETFCond cond, float duration, handle provider)": {
		"prefix": "AddCondEx",
		"body": [
			"AddCondEx(${1:ETFCond cond}, ${2:float duration}, ${3:handle provider})$0"
		],
		"description": ""
	},
	"void AddCustomAttribute(string, float, float)": {
		"prefix": "AddCustomAttribute",
		"body": [
			"AddCustomAttribute(${1:string}, ${2:float}, ${3:float})$0"
		],
		"description": "Add a custom attribute to the player"
	},
	"AddEFlags(int)": {
		"prefix": "AddEFlags",
		"body": [
			"AddEFlags(${1:int})$0"
		],
		"description": ""
	},
	"AddFlag(int)": {
		"prefix": "AddFlag",
		"body": [
			"AddFlag(${1:int})$0"
		],
		"description": ""
	},
	"void AddIncomingConnection(handle area, int dir)": {
		"prefix": "AddIncomingConnection",
		"body": [
			"AddIncomingConnection(${1:handle area}, ${2:int dir})$0"
		],
		"description": "Add areas that connect TO this area by a ONE-WAY link"
	},
	"void AddOutput(handle entity, string outputName, string targetName, string inputName, string parameter, float delay, int timesToFire)": {
		"prefix": "AddOutput",
		"body": [
			"AddOutput(${1:handle entity}, ${2:string outputName}, ${3:string targetName}, ${4:string inputName}, ${5:string parameter}, ${6:float delay}, ${7:int timesToFire})$0"
		],
		"description": "Adds a new output to the entity."
	},
	"AddSolidFlags(int)": {
		"prefix": "AddSolidFlags",
		"body": [
			"AddSolidFlags(${1:int})$0"
		],
		"description": ""
	},
	"void AddTemplate(string, handle)": {
		"prefix": "AddTemplate",
		"body": [
			"AddTemplate(${1:string}, ${2:handle})$0"
		],
		"description": "Add an entity to the template spawner"
	},
	"void AddThinkToEnt(handle entity, string FuncName)": {
		"prefix": "AddThinkToEnt",
		"body": [
			"AddThinkToEnt(${1:handle entity}, ${2:string FuncName})$0"
		],
		"description": "Sets a function in the entity's script to rerun by itself constantly. Pass null as the function name to remove a think function."
	},
	"AddToScriptHelp()": {
		"prefix": "AddToScriptHelp",
		"body": [
			"AddToScriptHelp()$0"
		],
		"description": ""
	},
	"void AddWeaponRestriction(int)": {
		"prefix": "AddWeaponRestriction",
		"body": [
			"AddWeaponRestriction(${1:int})$0"
		],
		"description": "Adds weapon restriction flags"
	},
	"bool AllowThirdPersonCamera()": {
		"prefix": "AllowThirdPersonCamera",
		"body": [
			"AllowThirdPersonCamera()$0"
		],
		"description": ""
	},
	"void ApplyAbsVelocityImpulse(Vector)": {
		"prefix": "ApplyAbsVelocityImpulse",
		"body": [
			"ApplyAbsVelocityImpulse(${1:Vector})$0"
		],
		"description": "Apply a Velocity Impulse"
	},
	"void ApplyLocalAngularVelocityImpulse(Vector)": {
		"prefix": "ApplyLocalAngularVelocityImpulse",
		"body": [
			"ApplyLocalAngularVelocityImpulse(${1:Vector})$0"
		],
		"description": "Apply an Ang Velocity Impulse"
	},
	"bool ApplyPunchImpulseX(float)": {
		"prefix": "ApplyPunchImpulseX",
		"body": [
			"ApplyPunchImpulseX(${1:float})$0"
		],
		"description": ""
	},
	"void Approach(Vector, float)": {
		"prefix": "Approach",
		"body": [
			"Approach(${1:Vector}, ${2:float})$0"
		],
		"description": "The primary locomotive method. Sets the goal destination for the bot"
	},
	"bool ArePlayersInHell()": {
		"prefix": "ArePlayersInHell",
		"body": [
			"ArePlayersInHell()$0"
		],
		"description": ""
	},
	"void Assert(bool value, string optional message)": {
		"prefix": "Assert",
		"body": [
			"Assert(${1:bool value}, ${2:string optional message})$0"
		],
		"description": "Test value and if not true, throws exception, optionally with message."
	},
	"bool BecomeRagdollOnClient(Vector)": {
		"prefix": "BecomeRagdollOnClient",
		"body": [
			"BecomeRagdollOnClient(${1:Vector})$0"
		],
		"description": "Becomes a ragdoll with a force"
	},
	"Begin()": {
		"prefix": "Begin",
		"body": [
			"Begin()$0"
		],
		"description": ""
	},
	"BeginScriptDebug()": {
		"prefix": "BeginScriptDebug",
		"body": [
			"BeginScriptDebug()$0"
		],
		"description": ""
	},
	"void BleedPlayer(float)": {
		"prefix": "BleedPlayer",
		"body": [
			"BleedPlayer(${1:float})$0"
		],
		"description": ""
	},
	"void BleedPlayerEx(float, int, bool, int)": {
		"prefix": "BleedPlayerEx",
		"body": [
			"BleedPlayerEx(${1:float}, ${2:int}, ${3:bool}, ${4:int})$0"
		],
		"description": ""
	},
	"Call()": {
		"prefix": "Call",
		"body": [
			"Call()$0"
		],
		"description": ""
	},
	"bool CanAirDash()": {
		"prefix": "CanAirDash",
		"body": [
			"CanAirDash()$0"
		],
		"description": ""
	},
	"bool CanBeDebuffed()": {
		"prefix": "CanBeDebuffed",
		"body": [
			"CanBeDebuffed()$0"
		],
		"description": ""
	},
	"bool CanBeSelected()": {
		"prefix": "CanBeSelected",
		"body": [
			"CanBeSelected()$0"
		],
		"description": "Can this weapon be selected"
	},
	"bool CanBreatheUnderwater()": {
		"prefix": "CanBreatheUnderwater",
		"body": [
			"CanBreatheUnderwater()$0"
		],
		"description": ""
	},
	"bool CanDuck()": {
		"prefix": "CanDuck",
		"body": [
			"CanDuck()$0"
		],
		"description": "Can the player duck?"
	},
	"bool CanGetWet()": {
		"prefix": "CanGetWet",
		"body": [
			"CanGetWet()$0"
		],
		"description": ""
	},
	"bool CanJump()": {
		"prefix": "CanJump",
		"body": [
			"CanJump()$0"
		],
		"description": "Can the player jump?"
	},
	"bool CanPlayerMove()": {
		"prefix": "CanPlayerMove",
		"body": [
			"CanPlayerMove()$0"
		],
		"description": "Can the player move?"
	},
	"void ClearAllBotAttributes()": {
		"prefix": "ClearAllBotAttributes",
		"body": [
			"ClearAllBotAttributes()$0"
		],
		"description": "Clears all attribute flags on this TFBot"
	},
	"void ClearAllBotTags()": {
		"prefix": "ClearAllBotTags",
		"body": [
			"ClearAllBotTags()$0"
		],
		"description": "Clears bot tags"
	},
	"void ClearAllWeaponRestrictions()": {
		"prefix": "ClearAllWeaponRestrictions",
		"body": [
			"ClearAllWeaponRestrictions()$0"
		],
		"description": "Removes all weapon restriction flags"
	},
	"void ClearAttentionFocus()": {
		"prefix": "ClearAttentionFocus",
		"body": [
			"ClearAttentionFocus()$0"
		],
		"description": "Clear current focus"
	},
	"void ClearAttributeTF(int)": {
		"prefix": "ClearAttributeTF",
		"body": [
			"ClearAttributeTF(${1:int})$0"
		],
		"description": "Clear TF-specific area attribute bits"
	},
	"void ClearCustomModelRotation()": {
		"prefix": "ClearCustomModelRotation",
		"body": [
			"ClearCustomModelRotation()$0"
		],
		"description": ""
	},
	"ClearFlags()": {
		"prefix": "ClearFlags",
		"body": [
			"ClearFlags()$0"
		],
		"description": ""
	},
	"void ClearGameEventCallbacks()": {
		"prefix": "ClearGameEventCallbacks",
		"body": [
			"ClearGameEventCallbacks()$0"
		],
		"description": "Empties the tables of game event callback functions."
	},
	"void ClearImmobileStatus()": {
		"prefix": "ClearImmobileStatus",
		"body": [
			"ClearImmobileStatus()$0"
		],
		"description": "Clear immobile status"
	},
	"ClearSolidFlags()": {
		"prefix": "ClearSolidFlags",
		"body": [
			"ClearSolidFlags()$0"
		],
		"description": ""
	},
	"void ClearSpells()": {
		"prefix": "ClearSpells",
		"body": [
			"ClearSpells()$0"
		],
		"description": ""
	},
	"void ClearStuckStatus(string)": {
		"prefix": "ClearStuckStatus",
		"body": [
			"ClearStuckStatus(${1:string})$0"
		],
		"description": "Reset stuck status to un-stuck"
	},
	"void ClientPrint(CBasePlayer player, int destination, string message)": {
		"prefix": "ClientPrint",
		"body": [
			"ClientPrint(${1:CBasePlayer player}, ${2:int destination}, ${3:string message})$0"
		],
		"description": "Print a client message. If you pass null instead of a valid player, the message will be sent to all clients."
	},
	"bool ClimbUpToLedge(Vector, Vector, handle)": {
		"prefix": "ClimbUpToLedge",
		"body": [
			"ClimbUpToLedge(${1:Vector}, ${2:Vector}, ${3:handle})$0"
		],
		"description": "Initiate a jump to an adjacent high ledge, return false if climb can't start"
	},
	"int Clip1()": {
		"prefix": "Clip1",
		"body": [
			"Clip1()$0"
		],
		"description": "Current ammo in clip1"
	},
	"int Clip2()": {
		"prefix": "Clip2",
		"body": [
			"Clip2()$0"
		],
		"description": "Current ammo in clip2"
	},
	"Vector ComputeClosestPointInPortal(handle, int, Vector)": {
		"prefix": "ComputeClosestPointInPortal",
		"body": [
			"ComputeClosestPointInPortal(${1:handle}, ${2:int}, ${3:Vector})$0"
		],
		"description": "Compute closest point within the portal between to adjacent areas."
	},
	"int ComputeDirection(Vector point)": {
		"prefix": "ComputeDirection",
		"body": [
			"ComputeDirection(${1:Vector point})$0"
		],
		"description": "Return direction from this area to the given point"
	},
	"bool ComputeUpdateInterval()": {
		"prefix": "ComputeUpdateInterval",
		"body": [
			"ComputeUpdateInterval()$0"
		],
		"description": "Recomputes the component update interval"
	},
	"void ConnectOutput(string, string)": {
		"prefix": "ConnectOutput",
		"body": [
			"ConnectOutput(${1:string}, ${2:string})$0"
		],
		"description": "Adds an I/O connection that will call the named function when the specified output fires"
	},
	"void ConnectTo(handle area, int dir)": {
		"prefix": "ConnectTo",
		"body": [
			"ConnectTo(${1:handle area}, ${2:int dir})$0"
		],
		"description": "Connect this area to given area in given direction"
	},
	"bool Contains(handle area)": {
		"prefix": "Contains",
		"body": [
			"Contains(${1:handle area})$0"
		],
		"description": "Return true if other area is on or above this area, but no others"
	},
	"bool ContainsOrigin(Vector point)": {
		"prefix": "ContainsOrigin",
		"body": [
			"ContainsOrigin(${1:Vector point})$0"
		],
		"description": "Return true if given point is on or above this area, but no others"
	},
	"handle CreateByClassname(string classname)": {
		"prefix": "CreateByClassname",
		"body": [
			"CreateByClassname(${1:string classname})$0"
		],
		"description": "Creates an entity by classname"
	},
	"handle CreateProp(string, Vector, string, int)": {
		"prefix": "CreateProp",
		"body": [
			"CreateProp(${1:string}, ${2:Vector}, ${3:string}, ${4:int})$0"
		],
		"description": "Create a physics prop"
	},
	"handle CreateSceneEntity(string)": {
		"prefix": "CreateSceneEntity",
		"body": [
			"CreateSceneEntity(${1:string})$0"
		],
		"description": "Create a scene entity to play the specified scene."
	},
	"float Cross(Vector factor)": {
		"prefix": "Cross",
		"body": [
			"Cross(${1:Vector factor})$0"
		],
		"description": "The vector product of two vectors. Returns a vector orthogonal to the input vectors."
	},
	"void DebugDrawBox(Vector origin, vector min, vector max, int r, int g, int b, int alpha, float duration)": {
		"prefix": "DebugDrawBox",
		"body": [
			"DebugDrawBox(${1:Vector origin}, ${2:vector min}, ${3:vector max}, ${4:int r}, ${5:int g}, ${6:int b}, ${7:int alpha}, ${8:float duration})$0"
		],
		"description": "Draw a debug overlay box."
	},
	"void DebugDrawBoxAngles(Vector origin, Vector min, Vector max, QAngle direction, Vector rgb, int alpha, float duration)": {
		"prefix": "DebugDrawBoxAngles",
		"body": [
			"DebugDrawBoxAngles(${1:Vector origin}, ${2:Vector min}, ${3:Vector max}, ${4:QAngle direction}, ${5:Vector rgb}, ${6:int alpha}, ${7:float duration})$0"
		],
		"description": "Draw a debug oriented box (cent, min, max, angles(p,y,r), vRgb, a, duration)."
	},
	"void DebugDrawBoxDirection(Vector center, Vector min, Vector max, Vector forward, Vector rgb, float alpha, float duration)": {
		"prefix": "DebugDrawBoxDirection",
		"body": [
			"DebugDrawBoxDirection(${1:Vector center}, ${2:Vector min}, ${3:Vector max}, ${4:Vector forward}, ${5:Vector rgb}, ${6:float alpha}, ${7:float duration})$0"
		],
		"description": "Draw a debug forward box."
	},
	"void DebugDrawCircle(Vector center, Vector rgb, float alpha, float radius, bool ztest, float duration)": {
		"prefix": "DebugDrawCircle",
		"body": [
			"DebugDrawCircle(${1:Vector center}, ${2:Vector rgb}, ${3:float alpha}, ${4:float radius}, ${5:bool ztest}, ${6:float duration})$0"
		],
		"description": "Draw a debug circle."
	},
	"void DebugDrawClear()": {
		"prefix": "DebugDrawClear",
		"body": [
			"DebugDrawClear()$0"
		],
		"description": "Try to clear all the debug overlay info."
	},
	"void DebugDrawFilled(int, int, int, int, float, bool, float)": {
		"prefix": "DebugDrawFilled",
		"body": [
			"DebugDrawFilled(${1:int}, ${2:int}, ${3:int}, ${4:int}, ${5:float}, ${6:bool}, ${7:float})$0"
		],
		"description": "Draw area as a filled rect of the given color"
	},
	"void DebugDrawLine(Vector start, Vector end, int red, int green, int blue', bool zTest, float time)": {
		"prefix": "DebugDrawLine",
		"body": [
			"DebugDrawLine(${1:Vector start}, ${2:Vector end}, ${3:int red}, ${4:int green}, ${5:int blue'}, ${6:bool zTest}, ${7:float time})$0"
		],
		"description": "Draw a debug overlay line."
	},
	"void DebugDrawLine_vCol(Vector start, vector end, vector rgb, bool ztest, float duration)": {
		"prefix": "DebugDrawLine_vCol",
		"body": [
			"DebugDrawLine_vCol(${1:Vector start}, ${2:vector end}, ${3:vector rgb}, ${4:bool ztest}, ${5:float duration})$0"
		],
		"description": "Draw a debug line using color vec."
	},
	"void DebugDrawScreenTextLine(float x, float y, int lineOffset, string text, int r, int g, int b, int a, float duration)": {
		"prefix": "DebugDrawScreenTextLine",
		"body": [
			"DebugDrawScreenTextLine(${1:float x}, ${2:float y}, ${3:int lineOffset}, ${4:string text}, ${5:int r}, ${6:int g}, ${7:int b}, ${8:int a}, ${9:float duration})$0"
		],
		"description": "Draw text with a line offset."
	},
	"void DebugDrawText(Vector origin, string text, bool useViewCheck, float duration)": {
		"prefix": "DebugDrawText",
		"body": [
			"DebugDrawText(${1:Vector origin}, ${2:string text}, ${3:bool useViewCheck}, ${4:float duration})$0"
		],
		"description": "Draw text on the screen, starting on the position of origin."
	},
	"void DelayedThreatNotice(handle, float)": {
		"prefix": "DelayedThreatNotice",
		"body": [
			"DelayedThreatNotice(${1:handle}, ${2:float})$0"
		],
		"description": ""
	},
	"void Destroy()": {
		"prefix": "Destroy",
		"body": [
			"Destroy()$0"
		],
		"description": ""
	},
	"void DisableDraw()": {
		"prefix": "DisableDraw",
		"body": [
			"DisableDraw()$0"
		],
		"description": "Enable drawing (removes EF_NODRAW)"
	},
	"void DisbandCurrentSquad()": {
		"prefix": "DisbandCurrentSquad",
		"body": [
			"DisbandCurrentSquad()$0"
		],
		"description": "Forces the current squad to be entirely disbanded by everyone"
	},
	"void Disconnect(handle area)": {
		"prefix": "Disconnect",
		"body": [
			"Disconnect(${1:handle area})$0"
		],
		"description": "Disconnect this area from given area"
	},
	"void DisconnectOutput(string, string)": {
		"prefix": "DisconnectOutput",
		"body": [
			"DisconnectOutput(${1:string}, ${2:string})$0"
		],
		"description": "Removes a connected script function from an I/O event."
	},
	"void DispatchAnimEvents(handle)": {
		"prefix": "DispatchAnimEvents",
		"body": [
			"DispatchAnimEvents(${1:handle})$0"
		],
		"description": "Dispatch animation events to a CBaseAnimating"
	},
	"void DispatchParticleEffect(string, Vector, Vector)": {
		"prefix": "DispatchParticleEffect",
		"body": [
			"DispatchParticleEffect(${1:string}, ${2:Vector}, ${3:Vector})$0"
		],
		"description": "Dispatches a one-off particle system"
	},
	"void DispatchSpawn(handle entity)": {
		"prefix": "DispatchSpawn",
		"body": [
			"DispatchSpawn(${1:handle entity})$0"
		],
		"description": "Dispatches spawn of an entity!"
	},
	"void DoEntFire(string target, string action, string value, float delay, handle activator, handle caller)": {
		"prefix": "DoEntFire",
		"body": [
			"DoEntFire(${1:string target}, ${2:string action}, ${3:string value}, ${4:float delay}, ${5:handle activator}, ${6:handle caller})$0"
		],
		"description": "Generate an entity I/O event. The caller and activator argument takes a CBaseEntity script handle, and entities assigned can receive inputs with target set to !self, or !activator / !caller."
	},
	"bool DoIncludeScript(string file, handle/table scope)": {
		"prefix": "DoIncludeScript",
		"body": [
			"DoIncludeScript(${1:string file}, ${2:handle/table scope})$0"
		],
		"description": "Execute a script. and put all its content for the argument passed to thescopeparameter. (internal)"
	},
	"string DoUniqueString(string input)": {
		"prefix": "DoUniqueString",
		"body": [
			"DoUniqueString(${1:string input})$0"
		],
		"description": "Unknown; presumably an internal function called by UniqueString, so call that instead."
	},
	"void Document(unknown symbolOrTable, unknown itemIfSymbol = null, string descriptionIfSymbol = null)": {
		"prefix": "Document",
		"body": [
			"Document(${1:unknown symbolOrTable}, ${2:unknown itemIfSymbol = null}, ${3:string descriptionIfSymbol = null})$0"
		],
		"description": ""
	},
	"float Dot(Quaternion factor)": {
		"prefix": "Dot",
		"body": [
			"Dot(${1:Quaternion factor})$0"
		],
		"description": "The 4D scalar product of two quaternions. represents the angle between the quaternions in the range [1, 0]."
	},
	"void DriveTo(Vector)": {
		"prefix": "DriveTo",
		"body": [
			"DriveTo(${1:Vector})$0"
		],
		"description": "Move the bot to the precise given position immediately, updating internal state"
	},
	"void DropFlag(bool)": {
		"prefix": "DropFlag",
		"body": [
			"DropFlag(${1:bool})$0"
		],
		"description": "Force player to drop the flag."
	},
	"void DropRune(bool, int)": {
		"prefix": "DropRune",
		"body": [
			"DropRune(${1:bool}, ${2:int})$0"
		],
		"description": "Force player to drop the rune."
	},
	"void DumpObject(handle object)": {
		"prefix": "DumpObject",
		"body": [
			"DumpObject(${1:handle object})$0"
		],
		"description": "Dumps information about a class or instance."
	},
	"void EmitAmbientSoundOn(string soundName, float volume, int soundlevel, int pitch, handle entity)": {
		"prefix": "EmitAmbientSoundOn",
		"body": [
			"EmitAmbientSoundOn(${1:string soundName}, ${2:float volume}, ${3:int soundlevel}, ${4:int pitch}, ${5:handle entity})$0"
		],
		"description": "Play named sound on an entity using configurations similar to ambient_generic."
	},
	"void EmitSound(string)": {
		"prefix": "EmitSound",
		"body": [
			"EmitSound(${1:string})$0"
		],
		"description": "Plays a sound from this entity."
	},
	"void EmitSoundOn(string soundScript, handle entity)": {
		"prefix": "EmitSoundOn",
		"body": [
			"EmitSoundOn(${1:string soundScript}, ${2:handle entity})$0"
		],
		"description": "Play named sound on an entity."
	},
	"void EmitSoundOnClient(string soundScript, handle player)": {
		"prefix": "EmitSoundOnClient",
		"body": [
			"EmitSoundOnClient(${1:string soundScript}, ${2:handle player})$0"
		],
		"description": "Play named sound only on the client for the specified player."
	},
	"void EnableDraw()": {
		"prefix": "EnableDraw",
		"body": [
			"EnableDraw()$0"
		],
		"description": "Disable drawing (sets EF_NODRAW)"
	},
	"End()": {
		"prefix": "End",
		"body": [
			"End()$0"
		],
		"description": ""
	},
	"EndScriptDebug()": {
		"prefix": "EndScriptDebug",
		"body": [
			"EndScriptDebug()$0"
		],
		"description": ""
	},
	"void EntFire(string target, string action, string value = null, float delay = 0, handle activator = null)": {
		"prefix": "EntFire",
		"body": [
			"EntFire(${1:string target}, ${2:string action}, ${3:string value = null}, ${4:float delay = 0}, ${5:handle activator = null})$0"
		],
		"description": "Wrapper for DoEntFire() that setsactivator to null, but has nocallerparam."
	},
	"void EntFireByHandle(handle, string, string, float, handle, handle)": {
		"prefix": "EntFireByHandle",
		"body": [
			"EntFireByHandle(${1:handle}, ${2:string}, ${3:string}, ${4:float}, ${5:handle}, ${6:handle})$0"
		],
		"description": "Generate and entity i/o event. First parameter is an entity instance."
	},
	"handle EntIndexToHScript(int entIndex)": {
		"prefix": "EntIndexToHScript",
		"body": [
			"EntIndexToHScript(${1:int entIndex})$0"
		],
		"description": "Turn an entity index integer to an HScript representing that entity's script instance."
	},
	"EstablishDelegation()": {
		"prefix": "EstablishDelegation",
		"body": [
			"EstablishDelegation()$0"
		],
		"description": ""
	},
	"float EstimateLength()": {
		"prefix": "EstimateLength",
		"body": [
			"EstimateLength()$0"
		],
		"description": "Returns length of this scene in seconds."
	},
	"void ExtinguishPlayerBurning()": {
		"prefix": "ExtinguishPlayerBurning",
		"body": [
			"ExtinguishPlayerBurning()$0"
		],
		"description": ""
	},
	"QAngle EyeAngles()": {
		"prefix": "EyeAngles",
		"body": [
			"EyeAngles()$0"
		],
		"description": "Returns the entity's eye angles"
	},
	"Vector EyePosition()": {
		"prefix": "EyePosition",
		"body": [
			"EyePosition()$0"
		],
		"description": "Get vector to eye position - absolute coords"
	},
	"void FaceTowards(Vector)": {
		"prefix": "FaceTowards",
		"body": [
			"FaceTowards(${1:Vector})$0"
		],
		"description": "Rotate body to face towards target"
	},
	"string FileToString(string file)": {
		"prefix": "FileToString",
		"body": [
			"FileToString(${1:string file})$0"
		],
		"description": "Reads a string from file. Returns the string from the file, null if no file or file is greater than 16384 bytes. The game will crash to desktop if the file is exactly 16384 bytes."
	},
	"int FindBodygroupByName(string)": {
		"prefix": "FindBodygroupByName",
		"body": [
			"FindBodygroupByName(${1:string})$0"
		],
		"description": "Find a bodygroup id by name"
	},
	"handle FindByClassname(handle previous, string classname)": {
		"prefix": "FindByClassname",
		"body": [
			"FindByClassname(${1:handle previous}, ${2:string classname})$0"
		],
		"description": "Find entities by the value of their classname keyvalue. Pass 'null' to start an iteration, or reference to a previously found entity to continue a search. Note: the classname keyvalue of an entity can be manipulated and does not necessarily reflect its code class. There might be entities that have a different classname than the one they are created with."
	},
	"handle FindByClassnameNearest(string classname, Vector center, float radius)": {
		"prefix": "FindByClassnameNearest",
		"body": [
			"FindByClassnameNearest(${1:string classname}, ${2:Vector center}, ${3:float radius})$0"
		],
		"description": "Find entities by classname nearest to a point."
	},
	"handle FindByClassnameWithin(handle previous, string classname, Vector center, float radius)": {
		"prefix": "FindByClassnameWithin",
		"body": [
			"FindByClassnameWithin(${1:handle previous}, ${2:string classname}, ${3:Vector center}, ${4:float radius})$0"
		],
		"description": "Find entities by classname within a radius. Pass 'null' to start an iteration, or reference to a previously found entity to continue a search"
	},
	"handle FindByModel(handle previous, string modelname)": {
		"prefix": "FindByModel",
		"body": [
			"FindByModel(${1:handle previous}, ${2:string modelname})$0"
		],
		"description": "Find entities by the value of their model keyvalue. Pass 'null' to start an iteration, or reference to a previously found entity to continue a search"
	},
	"handle FindByName(handle previous, string targetname)": {
		"prefix": "FindByName",
		"body": [
			"FindByName(${1:handle previous}, ${2:string targetname})$0"
		],
		"description": "Find entities by the value of their enttargetname keyvalue. Pass 'null' to start an iteration, or reference to a previously found entity to continue a search"
	},
	"handle FindByNameNearest(string targetname, Vector center, float radius)": {
		"prefix": "FindByNameNearest",
		"body": [
			"FindByNameNearest(${1:string targetname}, ${2:Vector center}, ${3:float radius})$0"
		],
		"description": "Find entities by targetname nearest to a point."
	},
	"handle FindByNameWithin(handle previous, string targetname, Vector center, float radius)": {
		"prefix": "FindByNameWithin",
		"body": [
			"FindByNameWithin(${1:handle previous}, ${2:string targetname}, ${3:Vector center}, ${4:float radius})$0"
		],
		"description": "Find entities by targetname within a radius. Pass 'null' to start an iteration, or reference to a previously found entity to continue a search"
	},
	"handle FindByTarget(handle previous, string target)": {
		"prefix": "FindByTarget",
		"body": [
			"FindByTarget(${1:handle previous}, ${2:string target})$0"
		],
		"description": "Find entities by the value of their target keyvalue. Pass 'null' to start an iteration, or reference to a previously found entity to continue a search"
	},
	"FindCircularReference()": {
		"prefix": "FindCircularReference",
		"body": [
			"FindCircularReference()$0"
		],
		"description": ""
	},
	"FindCircularReferences()": {
		"prefix": "FindCircularReferences",
		"body": [
			"FindCircularReferences()$0"
		],
		"description": ""
	},
	"handle FindInSphere(handle previous, Vector center, float radius)": {
		"prefix": "FindInSphere",
		"body": [
			"FindInSphere(${1:handle previous}, ${2:Vector center}, ${3:float radius})$0"
		],
		"description": "Find entities within a radius. Pass 'null' to start an iteration, or reference to a previously found entity to continue a search"
	},
	"CScriptKeyValues FindKey(string key)": {
		"prefix": "FindKey",
		"body": [
			"FindKey(${1:string key})$0"
		],
		"description": "Find a sub key by the key name."
	},
	"handle FindNamedEntity(string)": {
		"prefix": "FindNamedEntity",
		"body": [
			"FindNamedEntity(${1:string})$0"
		],
		"description": "given an entity reference, such as !target, get actual entity from scene object"
	},
	"handle FindNavAreaAlongRay(Vector startpos, Vector endpos, handle ignoreAreaID)": {
		"prefix": "FindNavAreaAlongRay",
		"body": [
			"FindNavAreaAlongRay(${1:Vector startpos}, ${2:Vector endpos}, ${3:handle ignoreAreaID})$0"
		],
		"description": "get nav area from ray"
	},
	"Vector FindRandomSpot()": {
		"prefix": "FindRandomSpot",
		"body": [
			"FindRandomSpot()$0"
		],
		"description": "Get random origin within extent of area"
	},
	"handle FindVantagePoint(float)": {
		"prefix": "FindVantagePoint",
		"body": [
			"FindVantagePoint(${1:float})$0"
		],
		"description": "Get the nav area of the closest vantage point (within distance)"
	},
	"bool FireGameEvent(string, handle)": {
		"prefix": "FireGameEvent",
		"body": [
			"FireGameEvent(${1:string}, ${2:handle})$0"
		],
		"description": "Fire a game event to a listening callback function in script. Parameters are passed in a squirrel table."
	},
	"void FireScriptEvent(string event, table params)": {
		"prefix": "FireScriptEvent",
		"body": [
			"FireScriptEvent(${1:string event}, ${2:table params})$0"
		],
		"description": "Wrapper for __RunEventCallbacks()"
	},
	"bool FireScriptHook(string, handle)": {
		"prefix": "FireScriptHook",
		"body": [
			"FireScriptHook(${1:string}, ${2:handle})$0"
		],
		"description": "Fire a script hoook to a listening callback function in script. Parameters are passed in a squirrel table."
	},
	"void FiringTalk()": {
		"prefix": "FiringTalk",
		"body": [
			"FiringTalk()$0"
		],
		"description": "Makes eg. a heavy go AAAAAAAAAAaAaa like they are firing their minigun."
	},
	"handle First()": {
		"prefix": "First",
		"body": [
			"First()$0"
		],
		"description": "Begin an iteration over the list of entities"
	},
	"FirstMoveChild()": {
		"prefix": "FirstMoveChild",
		"body": [
			"FirstMoveChild()$0"
		],
		"description": ""
	},
	"void FlagForUpdate(bool)": {
		"prefix": "FlagForUpdate",
		"body": [
			"FlagForUpdate(${1:bool})$0"
		],
		"description": "Flag this bot for update"
	},
	"bool FlagsMayBeCapped()": {
		"prefix": "FlagsMayBeCapped",
		"body": [
			"FlagsMayBeCapped()$0"
		],
		"description": "May a flag be captured?"
	},
	"void ForceChangeTeam(int, bool)": {
		"prefix": "ForceChangeTeam",
		"body": [
			"ForceChangeTeam(${1:int}, ${2:bool})$0"
		],
		"description": "Force player to change their team."
	},
	"void ForceEnableUpgrades(int)": {
		"prefix": "ForceEnableUpgrades",
		"body": [
			"ForceEnableUpgrades(${1:int})$0"
		],
		"description": "Whether to force on MvM-styled upgrades on/off. 0 -> default, 1 -> force off, 2 -> force on"
	},
	"void ForceEscortPushLogic(int)": {
		"prefix": "ForceEscortPushLogic",
		"body": [
			"ForceEscortPushLogic(${1:int})$0"
		],
		"description": "Forces payload pushing logic. 0 -> default, 1 -> force off, 2 -> force on"
	},
	"void ForceRegenerateAndRespawn(int, bool)": {
		"prefix": "ForceRegenerateAndRespawn",
		"body": [
			"ForceRegenerateAndRespawn(${1:int}, ${2:bool})$0"
		],
		"description": "Force regenerates and respawns the player"
	},
	"void ForceRespawn(int)": {
		"prefix": "ForceRespawn",
		"body": [
			"ForceRespawn(${1:int})$0"
		],
		"description": "Force respawns the player"
	},
	"Forward()": {
		"prefix": "Forward",
		"body": [
			"Forward()$0"
		],
		"description": ""
	},
	"float FractionPotentialGap(Vector, Vector)": {
		"prefix": "FractionPotentialGap",
		"body": [
			"FractionPotentialGap(${1:Vector}, ${2:Vector})$0"
		],
		"description": "If the locomotor cannot jump over the gap, returns the fraction of the jumpable ray"
	},
	"float FractionPotentiallyTraversable(Vector, Vector, bool)": {
		"prefix": "FractionPotentiallyTraversable",
		"body": [
			"FractionPotentiallyTraversable(${1:Vector}, ${2:Vector}, ${3:bool})$0"
		],
		"description": "If the locomotor could not move along the line given, returns the fraction of the walkable ray."
	},
	"float FrameTime()": {
		"prefix": "FrameTime",
		"body": [
			"FrameTime()$0"
		],
		"description": "Get the time spent on the server in the last frame"
	},
	"bool GameModeUsesCurrency()": {
		"prefix": "GameModeUsesCurrency",
		"body": [
			"GameModeUsesCurrency()$0"
		],
		"description": "Does the current gamemode have currency?"
	},
	"bool GameModeUsesMiniBosses()": {
		"prefix": "GameModeUsesMiniBosses",
		"body": [
			"GameModeUsesMiniBosses()$0"
		],
		"description": "Does the current gamemode have minibosses?"
	},
	"bool GameModeUsesUpgrades()": {
		"prefix": "GameModeUsesUpgrades",
		"body": [
			"GameModeUsesUpgrades()$0"
		],
		"description": "Does the current gamemode have upgrades?"
	},
	"void GenerateAndWearItem(string)": {
		"prefix": "GenerateAndWearItem",
		"body": [
			"GenerateAndWearItem(${1:string})$0"
		],
		"description": "Give me an item!"
	},
	"QAngle GetAbsAngles()": {
		"prefix": "GetAbsAngles",
		"body": [
			"GetAbsAngles()$0"
		],
		"description": "Get entity pitch, yaw, roll as QAngles"
	},
	"Vector GetAbsVelocity()": {
		"prefix": "GetAbsVelocity",
		"body": [
			"GetAbsVelocity()$0"
		],
		"description": "Returns the current absolute velocity of the entity"
	},
	"handle GetActiveWeapon()": {
		"prefix": "GetActiveWeapon",
		"body": [
			"GetActiveWeapon()$0"
		],
		"description": "Get the player's current weapon"
	},
	"handle GetAdjacentArea(int dir, int n)": {
		"prefix": "GetAdjacentArea",
		"body": [
			"GetAdjacentArea(${1:int dir}, ${2:int n})$0"
		],
		"description": "Return the n'th adjacent area in the given direction"
	},
	"void GetAdjacentAreas(int dir, handle table)": {
		"prefix": "GetAdjacentAreas",
		"body": [
			"GetAdjacentAreas(${1:int dir}, ${2:handle table})$0"
		],
		"description": "Fills a passed in table with all adjacent areas in the given direction"
	},
	"int GetAdjacentCount(int dir)": {
		"prefix": "GetAdjacentCount",
		"body": [
			"GetAdjacentCount(${1:int dir})$0"
		],
		"description": "Get the number of adjacent areas in the given direction"
	},
	"void GetAllAreas(handle table)": {
		"prefix": "GetAllAreas",
		"body": [
			"GetAllAreas(${1:handle table})$0"
		],
		"description": "fills a passed in table of all nav areas"
	},
	"Vector GetAngles()": {
		"prefix": "GetAngles",
		"body": [
			"GetAngles()$0"
		],
		"description": "Get entity pitch, yaw, roll as a vector"
	},
	"Vector GetAngularVelocity()": {
		"prefix": "GetAngularVelocity",
		"body": [
			"GetAngularVelocity()$0"
		],
		"description": "Get the local angular velocity - returns a vector of pitch,yaw,roll"
	},
	"void GetAreasWithAttributes(int bits, handle table)": {
		"prefix": "GetAreasWithAttributes",
		"body": [
			"GetAreasWithAttributes(${1:int bits}, ${2:handle table})$0"
		],
		"description": "fills a passed in table of all nav areas that have the specified attributes"
	},
	"QAngle GetAttachmentAngles(int)": {
		"prefix": "GetAttachmentAngles",
		"body": [
			"GetAttachmentAngles(${1:int})$0"
		],
		"description": "Get the attachement id's angles as a p,y,r vector"
	},
	"int GetAttachmentBone(int)": {
		"prefix": "GetAttachmentBone",
		"body": [
			"GetAttachmentBone(${1:int})$0"
		],
		"description": "Get the named attachement's parent bone index"
	},
	"Vector GetAttachmentOrigin(int)": {
		"prefix": "GetAttachmentOrigin",
		"body": [
			"GetAttachmentOrigin(${1:int})$0"
		],
		"description": "Get the attachement id's origin vector"
	},
	"int GetAttributes()": {
		"prefix": "GetAttributes",
		"body": [
			"GetAttributes()$0"
		],
		"description": "Get area attribute bits"
	},
	"float GetAvoidanceObstacleHeight()": {
		"prefix": "GetAvoidanceObstacleHeight",
		"body": [
			"GetAvoidanceObstacleHeight()$0"
		],
		"description": "Returns the maximum height of the obstruction above the ground"
	},
	"int GetBackstabs()": {
		"prefix": "GetBackstabs",
		"body": [
			"GetBackstabs()$0"
		],
		"description": ""
	},
	"Vector GetBaseVelocity()": {
		"prefix": "GetBaseVelocity",
		"body": [
			"GetBaseVelocity()$0"
		],
		"description": "Returns any constant velocity currently being imparted onto the entity. This includes being pushed by effects like enttrigger_push and players standing on moving geometry like elevators. Should always returns a zero vector if the entity is not affected by any movement effects."
	},
	"handle GetBodyInterface()": {
		"prefix": "GetBodyInterface",
		"body": [
			"GetBodyInterface()$0"
		],
		"description": "Get this bot's body interface"
	},
	"int GetBodygroup(int)": {
		"prefix": "GetBodygroup",
		"body": [
			"GetBodygroup(${1:int})$0"
		],
		"description": "Get a bodygroup by id"
	},
	"string GetBodygroupName(int)": {
		"prefix": "GetBodygroupName",
		"body": [
			"GetBodygroupName(${1:int})$0"
		],
		"description": "Get the bodygroup id's name"
	},
	"string GetBodygroupPartName(int, int)": {
		"prefix": "GetBodygroupPartName",
		"body": [
			"GetBodygroupPartName(${1:int}, ${2:int})$0"
		],
		"description": "Get name by group and part"
	},
	"QAngle GetBoneAngles(int)": {
		"prefix": "GetBoneAngles",
		"body": [
			"GetBoneAngles(${1:int})$0"
		],
		"description": "Get the bone id's angles as a p,y,r vector"
	},
	"Vector GetBoneOrigin(int)": {
		"prefix": "GetBoneOrigin",
		"body": [
			"GetBoneOrigin(${1:int})$0"
		],
		"description": "Get the bone id's origin vector"
	},
	"int GetBonusPoints()": {
		"prefix": "GetBonusPoints",
		"body": [
			"GetBonusPoints()$0"
		],
		"description": ""
	},
	"bool GetClientConvarValue(string name)": {
		"prefix": "GetClientConvarValue",
		"body": [
			"GetClientConvarValue(${1:string name})$0"
		],
		"description": "Returns the convar as a bool. May return null if no such convar."
	},
	"int GetBotId()": {
		"prefix": "GetBotId",
		"body": [
			"GetBotId()$0"
		],
		"description": "Get this bot's id"
	},
	"Vector GetBoundingMaxs()": {
		"prefix": "GetBoundingMaxs",
		"body": [
			"GetBoundingMaxs()$0"
		],
		"description": "Get a vector containing max bounds, centered on object"
	},
	"Vector GetBoundingMaxsOriented()": {
		"prefix": "GetBoundingMaxsOriented",
		"body": [
			"GetBoundingMaxsOriented()$0"
		],
		"description": "Get a vector containing max bounds, centered on object, taking the object's orientation into account"
	},
	"Vector GetBoundingMins()": {
		"prefix": "GetBoundingMins",
		"body": [
			"GetBoundingMins()$0"
		],
		"description": "Get a vector containing min bounds, centered on object"
	},
	"Vector GetBoundingMinsOriented()": {
		"prefix": "GetBoundingMinsOriented",
		"body": [
			"GetBoundingMinsOriented()$0"
		],
		"description": "Get a vector containing min bounds, centered on object, taking the object's orientation into account"
	},
	"int GetBuildingsDestroyed()": {
		"prefix": "GetBuildingsDestroyed",
		"body": [
			"GetBuildingsDestroyed()$0"
		],
		"description": ""
	},
	"int GetCaptures()": {
		"prefix": "GetCaptures",
		"body": [
			"GetCaptures()$0"
		],
		"description": ""
	},
	"Vector GetCenter()": {
		"prefix": "GetCenter",
		"body": [
			"GetCenter()$0"
		],
		"description": "Get center origin of area"
	},
	"Vector GetClassEyeHeight()": {
		"prefix": "GetClassEyeHeight",
		"body": [
			"GetClassEyeHeight()$0"
		],
		"description": "Gets the eye height of the player"
	},
	"int GetClassLimit(int)": {
		"prefix": "GetClassLimit",
		"body": [
			"GetClassLimit(${1:int})$0"
		],
		"description": "Get class limit for class. See Constants.ETFClass"
	},
	"string GetClassname()": {
		"prefix": "GetClassname",
		"body": [
			"GetClassname()$0"
		],
		"description": ""
	},
	"string GetClientConvarValue(string name, int entindex)": {
		"prefix": "GetClientConvarValue",
		"body": [
			"GetClientConvarValue(${1:string name}, ${2:int entindex})$0"
		],
		"description": "Returns the convar value for the entindex as a string. Only works on client convars with the FCVAR_USERINFO flag."
	},
	"GetCollisionGroup()": {
		"prefix": "GetCollisionGroup",
		"body": [
			"GetCollisionGroup()$0"
		],
		"description": ""
	},
	"float GetCondDuration(ETFCond cond)": {
		"prefix": "GetCondDuration",
		"body": [
			"GetCondDuration(${1:ETFCond cond})$0"
		],
		"description": ""
	},
	"Vector GetCorner(int dir)": {
		"prefix": "GetCorner",
		"body": [
			"GetCorner(${1:int dir})$0"
		],
		"description": "Get corner origin of area"
	},
	"int GetCurrency()": {
		"prefix": "GetCurrency",
		"body": [
			"GetCurrency()$0"
		],
		"description": "Get player's cash for game modes with upgrades, ie. MvM"
	},
	"float GetCurrentTauntMoveSpeed()": {
		"prefix": "GetCurrentTauntMoveSpeed",
		"body": [
			"GetCurrentTauntMoveSpeed()$0"
		],
		"description": ""
	},
	"float GetCycle()": {
		"prefix": "GetCycle",
		"body": [
			"GetCycle()$0"
		],
		"description": "Gets the models current cycle"
	},
	"float GetDeathDropHeight()": {
		"prefix": "GetDeathDropHeight",
		"body": [
			"GetDeathDropHeight()$0"
		],
		"description": "Distance at which we will die if we fall"
	},
	"int GetDefaultClip1()": {
		"prefix": "GetDefaultClip1",
		"body": [
			"GetDefaultClip1()$0"
		],
		"description": "Default size of clip1"
	},
	"int GetDefaultClip2()": {
		"prefix": "GetDefaultClip2",
		"body": [
			"GetDefaultClip2()$0"
		],
		"description": "Default size of clip2"
	},
	"int GetDefenses()": {
		"prefix": "GetDefenses",
		"body": [
			"GetDefenses()$0"
		],
		"description": ""
	},
	"float GetDesiredSpeed()": {
		"prefix": "GetDesiredSpeed",
		"body": [
			"GetDesiredSpeed()$0"
		],
		"description": "Get desired speed for locomotor movement"
	},
	"int GetDeveloperLevel()": {
		"prefix": "GetDeveloperLevel",
		"body": [
			"GetDeveloperLevel()$0"
		],
		"description": "Gets the level of 'developer'"
	},
	"int GetDifficulty()": {
		"prefix": "GetDifficulty",
		"body": [
			"GetDifficulty()$0"
		],
		"description": "Returns the bot's difficulty level"
	},
	"int GetDisguiseAmmoCount()": {
		"prefix": "GetDisguiseAmmoCount",
		"body": [
			"GetDisguiseAmmoCount()$0"
		],
		"description": ""
	},
	"handle GetDisguiseTarget()": {
		"prefix": "GetDisguiseTarget",
		"body": [
			"GetDisguiseTarget()$0"
		],
		"description": ""
	},
	"int GetDisguiseTeam()": {
		"prefix": "GetDisguiseTeam",
		"body": [
			"GetDisguiseTeam()$0"
		],
		"description": ""
	},
	"float GetDistanceSquaredToPoint(Vector pos)": {
		"prefix": "GetDistanceSquaredToPoint",
		"body": [
			"GetDistanceSquaredToPoint(${1:Vector pos})$0"
		],
		"description": "Return shortest distance between point and this area"
	},
	"int GetDominations()": {
		"prefix": "GetDominations",
		"body": [
			"GetDominations()$0"
		],
		"description": ""
	},
	"handle GetDoor()": {
		"prefix": "GetDoor",
		"body": [
			"GetDoor()$0"
		],
		"description": "Returns the door entity above the area"
	},
	"int GetEFlags()": {
		"prefix": "GetEFlags",
		"body": [
			"GetEFlags()$0"
		],
		"description": ""
	},
	"handle GetElevator()": {
		"prefix": "GetElevator",
		"body": [
			"GetElevator()$0"
		],
		"description": "Returns the elevator if in an elevator's path"
	},
	"void GetElevatorAreas(handle table)": {
		"prefix": "GetElevatorAreas",
		"body": [
			"GetElevatorAreas(${1:handle table})$0"
		],
		"description": "Fills table with a collection of areas reachable via elevator from this area"
	},
	"GetEntityHandle()": {
		"prefix": "GetEntityHandle",
		"body": [
			"GetEntityHandle()$0"
		],
		"description": "Get the entity as an EHANDLE"
	},
	"int GetEntityIndex()": {
		"prefix": "GetEntityIndex",
		"body": [
			"GetEntityIndex()$0"
		],
		"description": ""
	},
	"Vector GetFeet()": {
		"prefix": "GetFeet",
		"body": [
			"GetFeet()$0"
		],
		"description": "Return position of feet - the driving point where the bot contacts the ground"
	},
	"CScriptKeyValues GetFirstSubKey()": {
		"prefix": "GetFirstSubKey",
		"body": [
			"GetFirstSubKey()$0"
		],
		"description": "Return the first sub key object."
	},
	"int GetFlags()": {
		"prefix": "GetFlags",
		"body": [
			"GetFlags()$0"
		],
		"description": ""
	},
	"float GetFloat(string name)": {
		"prefix": "GetFloat",
		"body": [
			"GetFloat(${1:string name})$0"
		],
		"description": "Returns the convar as a float. May return null if no such convar."
	},
	"bool GetForceLocalDraw()": {
		"prefix": "GetForceLocalDraw",
		"body": [
			"GetForceLocalDraw()$0"
		],
		"description": "Gets the state of whether the player is being forced by SetForceLocalDraw to be drawn"
	},
	"Vector GetForwardVector()": {
		"prefix": "GetForwardVector",
		"body": [
			"GetForwardVector()$0"
		],
		"description": "Get the forward vector of the entity"
	},
	"int GetFrameCount()": {
		"prefix": "GetFrameCount",
		"body": [
			"GetFrameCount()$0"
		],
		"description": "Returns the engines current frame count"
	},
	"float GetFriction(handle player)": {
		"prefix": "GetFriction",
		"body": [
			"GetFriction(${1:handle player})$0"
		],
		"description": "Returns the Friction on a player entity, meaningless if not a player"
	},
	"GetFunctionSignature()": {
		"prefix": "GetFunctionSignature",
		"body": [
			"GetFunctionSignature()$0"
		],
		"description": ""
	},
	"Vector GetFuturePosition(float, float)": {
		"prefix": "GetFuturePosition",
		"body": [
			"GetFuturePosition(${1:float}, ${2:float})$0"
		],
		"description": "Get a position on the track x seconds in the future"
	},
	"handle GetGrapplingHookTarget()": {
		"prefix": "GetGrapplingHookTarget",
		"body": [
			"GetGrapplingHookTarget()$0"
		],
		"description": "What entity is the player grappling?"
	},
	"float GetGravity()": {
		"prefix": "GetGravity",
		"body": [
			"GetGravity()$0"
		],
		"description": ""
	},
	"float GetGravityMultiplier()": {
		"prefix": "GetGravityMultiplier",
		"body": [
			"GetGravityMultiplier()$0"
		],
		"description": ""
	},
	"handle GetGround()": {
		"prefix": "GetGround",
		"body": [
			"GetGround()$0"
		],
		"description": "Return the current ground entity or NULL if not on the ground"
	},
	"Vector GetGroundMotionVector()": {
		"prefix": "GetGroundMotionVector",
		"body": [
			"GetGroundMotionVector()$0"
		],
		"description": "Return unit vector in XY plane describing our direction of motion - even if we are currently not moving"
	},
	"Vector GetGroundNormal()": {
		"prefix": "GetGroundNormal",
		"body": [
			"GetGroundNormal()$0"
		],
		"description": "Surface normal of the ground we are in contact with"
	},
	"float GetGroundSpeed()": {
		"prefix": "GetGroundSpeed",
		"body": [
			"GetGroundSpeed()$0"
		],
		"description": "Return current world space speed in XY plane"
	},
	"int GetHeadshots()": {
		"prefix": "GetHeadshots",
		"body": [
			"GetHeadshots()$0"
		],
		"description": ""
	},
	"int GetHealPoints()": {
		"prefix": "GetHealPoints",
		"body": [
			"GetHealPoints()$0"
		],
		"description": ""
	},
	"handle GetHealTarget()": {
		"prefix": "GetHealTarget",
		"body": [
			"GetHealTarget()$0"
		],
		"description": "Who is the medic healing?"
	},
	"int GetHealth()": {
		"prefix": "GetHealth",
		"body": [
			"GetHealth()$0"
		],
		"description": ""
	},
	"handle GetHomeArea()": {
		"prefix": "GetHomeArea",
		"body": [
			"GetHomeArea()$0"
		],
		"description": "Sets the home nav area of the bot"
	},
	"int GetID()": {
		"prefix": "GetID",
		"body": [
			"GetID()$0"
		],
		"description": "Get area ID."
	},
	"float GetImmobileDuration()": {
		"prefix": "GetImmobileDuration",
		"body": [
			"GetImmobileDuration()$0"
		],
		"description": "How long have we been immobile"
	},
	"float GetImmobileSpeedThreshold()": {
		"prefix": "GetImmobileSpeedThreshold",
		"body": [
			"GetImmobileSpeedThreshold()$0"
		],
		"description": "Return units/second below which this actor is considered immobile"
	},
	"void GetIncomingConnections(int dir, handle table)": {
		"prefix": "GetIncomingConnections",
		"body": [
			"GetIncomingConnections(${1:int dir}, ${2:handle table})$0"
		],
		"description": "Fills a passed in table with areas connected TO this area by a ONE-WAY link (ie: we have no connection back to them)"
	},
	"int GetInt(string name)": {
		"prefix": "GetInt",
		"body": [
			"GetInt(${1:string name})$0"
		],
		"description": "Returns the convar as an int. May return null if no such convar."
	},
	"handle GetIntentionInterface()": {
		"prefix": "GetIntentionInterface",
		"body": [
			"GetIntentionInterface()$0"
		],
		"description": "Get this bot's intention interface"
	},
	"int GetInvulns()": {
		"prefix": "GetInvulns",
		"body": [
			"GetInvulns()$0"
		],
		"description": ""
	},
	"bool GetKeyBool(string key)": {
		"prefix": "GetKeyBool",
		"body": [
			"GetKeyBool(${1:string key})$0"
		],
		"description": "Return the key value as a bool."
	},
	"float GetKeyFloat(string key)": {
		"prefix": "GetKeyFloat",
		"body": [
			"GetKeyFloat(${1:string key})$0"
		],
		"description": "Return the key value as a float."
	},
	"int GetKeyInt(string key)": {
		"prefix": "GetKeyInt",
		"body": [
			"GetKeyInt(${1:string key})$0"
		],
		"description": "Return the key value as an integer."
	},
	"string GetKeyString(string key)": {
		"prefix": "GetKeyString",
		"body": [
			"GetKeyString(${1:string key})$0"
		],
		"description": "Return the key value as a string."
	},
	"int GetKillAssists()": {
		"prefix": "GetKillAssists",
		"body": [
			"GetKillAssists()$0"
		],
		"description": ""
	},
	"handle GetLastKnownArea()": {
		"prefix": "GetLastKnownArea",
		"body": [
			"GetLastKnownArea()$0"
		],
		"description": "Return the last nav area occupied - NULL if unknown"
	},
	"Vector GetLeftVector()": {
		"prefix": "GetLeftVector",
		"body": [
			"GetLeftVector()$0"
		],
		"description": "Get the right vector of the entity. This is purely for compatibility."
	},
	"handle GetListenServerHost()": {
		"prefix": "GetListenServerHost",
		"body": [
			"GetListenServerHost()$0"
		],
		"description": "Get the local player on a listen server."
	},
	"QAngle GetLocalAngles()": {
		"prefix": "GetLocalAngles",
		"body": [
			"GetLocalAngles()$0"
		],
		"description": ""
	},
	"Vector GetLocalOrigin()": {
		"prefix": "GetLocalOrigin",
		"body": [
			"GetLocalOrigin()$0"
		],
		"description": ""
	},
	"Vector GetLocalVelocity()": {
		"prefix": "GetLocalVelocity",
		"body": [
			"GetLocalVelocity()$0"
		],
		"description": "Get Entity relative velocity"
	},
	"handle GetLocomotionInterface()": {
		"prefix": "GetLocomotionInterface",
		"body": [
			"GetLocomotionInterface()$0"
		],
		"description": "Get this bot's locomotion interface"
	},
	"bool GetMannVsMachineAlarmStatus()": {
		"prefix": "GetMannVsMachineAlarmStatus",
		"body": [
			"GetMannVsMachineAlarmStatus()$0"
		],
		"description": ""
	},
	"string GetMapName()": {
		"prefix": "GetMapName",
		"body": [
			"GetMapName()$0"
		],
		"description": "Get the name of the map."
	},
	"float GetMaxAcceleration()": {
		"prefix": "GetMaxAcceleration",
		"body": [
			"GetMaxAcceleration()$0"
		],
		"description": "Return maximum acceleration of locomotor"
	},
	"int GetMaxClip1()": {
		"prefix": "GetMaxClip1",
		"body": [
			"GetMaxClip1()$0"
		],
		"description": "Max size of clip1"
	},
	"int GetMaxClip2()": {
		"prefix": "GetMaxClip2",
		"body": [
			"GetMaxClip2()$0"
		],
		"description": "Max size of clip2"
	},
	"float GetMaxDeceleration()": {
		"prefix": "GetMaxDeceleration",
		"body": [
			"GetMaxDeceleration()$0"
		],
		"description": "Return maximum deceleration of locomotor"
	},
	"int GetMaxHealth()": {
		"prefix": "GetMaxHealth",
		"body": [
			"GetMaxHealth()$0"
		],
		"description": ""
	},
	"float GetMaxJumpHeight()": {
		"prefix": "GetMaxJumpHeight",
		"body": [
			"GetMaxJumpHeight()$0"
		],
		"description": "Return maximum height of a jump"
	},
	"float GetMaxVisionRangeOverride()": {
		"prefix": "GetMaxVisionRangeOverride",
		"body": [
			"GetMaxVisionRangeOverride()$0"
		],
		"description": "Gets the max vision range override for the bot"
	},
	"int GetModelIndex(string filename)": {
		"prefix": "GetModelIndex",
		"body": [
			"GetModelIndex(${1:string filename})$0"
		],
		"description": "Returns the index of the named model."
	},
	"handle GetModelKeyValues()": {
		"prefix": "GetModelKeyValues",
		"body": [
			"GetModelKeyValues()$0"
		],
		"description": "Get a KeyValue class instance on this entity's model"
	},
	"string GetModelName()": {
		"prefix": "GetModelName",
		"body": [
			"GetModelName()$0"
		],
		"description": "Returns the name of the model"
	},
	"float GetModelScale()": {
		"prefix": "GetModelScale",
		"body": [
			"GetModelScale()$0"
		],
		"description": ""
	},
	"Vector GetMotionVector()": {
		"prefix": "GetMotionVector",
		"body": [
			"GetMotionVector()$0"
		],
		"description": "Return unit vector describing our direction of motion - even if we are currently not moving"
	},
	"handle GetMoveParent()": {
		"prefix": "GetMoveParent",
		"body": [
			"GetMoveParent()$0"
		],
		"description": "If in hierarchy, retrieves the entity's parent"
	},
	"int GetMoveType()": {
		"prefix": "GetMoveType",
		"body": [
			"GetMoveType()$0"
		],
		"description": ""
	},
	"string GetName()": {
		"prefix": "GetName",
		"body": [
			"GetName()$0"
		],
		"description": "Gets the weapon's name"
	},
	"handle GetNavArea(Vector origin, float flBeneath)": {
		"prefix": "GetNavArea",
		"body": [
			"GetNavArea(${1:Vector origin}, ${2:float flBeneath})$0"
		],
		"description": "given a position in the world, return the nav area that is closest to or below that height."
	},
	"handle GetNavAreaByID(int areaID)": {
		"prefix": "GetNavAreaByID",
		"body": [
			"GetNavAreaByID(${1:int areaID})$0"
		],
		"description": "get nav area by ID"
	},
	"int GetNavAreaCount()": {
		"prefix": "GetNavAreaCount",
		"body": [
			"GetNavAreaCount()$0"
		],
		"description": "return total number of nav areas"
	},
	"bool GetNavAreasFromBuildPath(CTFNavArea startArea, CTFNavArea endArea, Vector goalPos, float flMaxPathLength, int teamID, bool ignoreNavBlockers, handle table)": {
		"prefix": "GetNavAreasFromBuildPath",
		"body": [
			"GetNavAreasFromBuildPath(${1:CTFNavArea startArea}, ${2:CTFNavArea endArea}, ${3:Vector goalPos}, ${4:float flMaxPathLength}, ${5:int teamID}, ${6:bool ignoreNavBlockers}, ${7:handle table})$0"
		],
		"description": "Fills the table with areas from a path. Returns whether a path was found. If 'endArea' is NULL, will compute a path as close as possible to 'goalPos'."
	},
	"void GetNavAreasInRadius(Vector origin, float radius, handle table)": {
		"prefix": "GetNavAreasInRadius",
		"body": [
			"GetNavAreasInRadius(${1:Vector origin}, ${2:float radius}, ${3:handle table})$0"
		],
		"description": "fills a passed in table of nav areas within radius"
	},
	"void GetNavAreasOverlappingEntityExtent(handle entity, handle table)": {
		"prefix": "GetNavAreasOverlappingEntityExtent",
		"body": [
			"GetNavAreasOverlappingEntityExtent(${1:handle entity}, ${2:handle table})$0"
		],
		"description": "fills passed in table with areas overlapping entity's extent"
	},
	"handle GetNearestKnownSappableTarget()": {
		"prefix": "GetNearestKnownSappableTarget",
		"body": [
			"GetNearestKnownSappableTarget()$0"
		],
		"description": "Gets the nearest known sappable target"
	},
	"handle GetNearestNavArea(Vector origin, float maxDist, bool checkLOS, bool checkGround)": {
		"prefix": "GetNearestNavArea",
		"body": [
			"GetNearestNavArea(${1:Vector origin}, ${2:float maxDist}, ${3:bool checkLOS}, ${4:bool checkGround})$0"
		],
		"description": "given a position in the world, return the nav area that is closest to or below that height."
	},
	"float GetNextChangeClassTime()": {
		"prefix": "GetNextChangeClassTime",
		"body": [
			"GetNextChangeClassTime()$0"
		],
		"description": "Get next change class time."
	},
	"float GetNextChangeTeamTime()": {
		"prefix": "GetNextChangeTeamTime",
		"body": [
			"GetNextChangeTeamTime()$0"
		],
		"description": "Get next change team time."
	},
	"CScriptKeyValues GetNextKey()": {
		"prefix": "GetNextKey",
		"body": [
			"GetNextKey()$0"
		],
		"description": "Return the next neighbor key object to the one the method is called on."
	},
	"float GetNextRegenTime()": {
		"prefix": "GetNextRegenTime",
		"body": [
			"GetNextRegenTime()$0"
		],
		"description": "Get next health regen time."
	},
	"int GetNumElements(handle ntity entity, string outputName)": {
		"prefix": "GetNumElements",
		"body": [
			"GetNumElements(${1:handle ntity entity}, ${2:string outputName})$0"
		],
		"description": "Returns the number of array elements."
	},
	"void GetObstructingEntities(handle table)": {
		"prefix": "GetObstructingEntities",
		"body": [
			"GetObstructingEntities(${1:handle table})$0"
		],
		"description": "fills a passed in table of all obstructing entities"
	},
	"Vector GetOrigin()": {
		"prefix": "GetOrigin",
		"body": [
			"GetOrigin()$0"
		],
		"description": "This is GetAbsOrigin with a funny script name for some reason. Not changing it for legacy compat though."
	},
	"void GetOutputTable(handle entity, string outputName, table, int arrayElement)": {
		"prefix": "GetOutputTable",
		"body": [
			"GetOutputTable(${1:handle entity}, ${2:string outputName}, ${3:table}, ${4:int arrayElement})$0"
		],
		"description": "Fills the passed table with output information."
	},
	"bool GetOvertimeAllowedForCTF()": {
		"prefix": "GetOvertimeAllowedForCTF",
		"body": [
			"GetOvertimeAllowedForCTF()$0"
		],
		"description": ""
	},
	"handle GetOwner()": {
		"prefix": "GetOwner",
		"body": [
			"GetOwner()$0"
		],
		"description": "Gets this entity's owner"
	},
	"handle GetParent()": {
		"prefix": "GetParent",
		"body": [
			"GetParent()$0"
		],
		"description": "Returns the area just prior to this one in the search path"
	},
	"int GetParentHow()": {
		"prefix": "GetParentHow",
		"body": [
			"GetParentHow()$0"
		],
		"description": "Returns how we get from parent to us"
	},
	"Vector GetPhysAngularVelocity(handle entity)": {
		"prefix": "GetPhysAngularVelocity",
		"body": [
			"GetPhysAngularVelocity(${1:handle entity})$0"
		],
		"description": "Returns the Angular velocity of the entity."
	},
	"Vector GetPhysVelocity(handle entity)": {
		"prefix": "GetPhysVelocity",
		"body": [
			"GetPhysVelocity(${1:handle entity})$0"
		],
		"description": "Returns the velocity of the entity."
	},
	"string GetPlaceName()": {
		"prefix": "GetPlaceName",
		"body": [
			"GetPlaceName()$0"
		],
		"description": "Get place name"
	},
	"float GetPlaybackRate()": {
		"prefix": "GetPlaybackRate",
		"body": [
			"GetPlaybackRate()$0"
		],
		"description": "Set the current playback rate."
	},
	"int GetPlayerClass()": {
		"prefix": "GetPlayerClass",
		"body": [
			"GetPlayerClass()$0"
		],
		"description": ""
	},
	"int GetPlayerCount(int team)": {
		"prefix": "GetPlayerCount",
		"body": [
			"GetPlayerCount(${1:int team})$0"
		],
		"description": "Return number of players of given team currently within this area (team of zero means any/all)"
	},
	"handle GetPlayerFromUserID(int ID)": {
		"prefix": "GetPlayerFromUserID",
		"body": [
			"GetPlayerFromUserID(${1:int ID})$0"
		],
		"description": "Given a user id, return the entity, or null."
	},
	"Vector GetPlayerMaxs()": {
		"prefix": "GetPlayerMaxs",
		"body": [
			"GetPlayerMaxs()$0"
		],
		"description": ""
	},
	"Vector GetPlayerMins()": {
		"prefix": "GetPlayerMins",
		"body": [
			"GetPlayerMins()$0"
		],
		"description": ""
	},
	"float GetPlayerSpeechDuration(int)": {
		"prefix": "GetPlayerSpeechDuration",
		"body": [
			"GetPlayerSpeechDuration(${1:int})$0"
		],
		"description": "Returns the number of seconds the player has been continuously speaking."
	},
	"int GetPosition()": {
		"prefix": "GetPosition",
		"body": [
			"GetPosition()$0"
		],
		"description": "Gets the weapon's current position"
	},
	"string GetPreTemplateName()": {
		"prefix": "GetPreTemplateName",
		"body": [
			"GetPreTemplateName()$0"
		],
		"description": "Get the entity name stripped of template unique decoration"
	},
	"int GetPrimaryAmmoCount()": {
		"prefix": "GetPrimaryAmmoCount",
		"body": [
			"GetPrimaryAmmoCount()$0"
		],
		"description": "Current primary ammo count if no clip is used or to give a player if they pick up this weapon legacy style (not TF)"
	},
	"int GetPrimaryAmmoType()": {
		"prefix": "GetPrimaryAmmoType",
		"body": [
			"GetPrimaryAmmoType()$0"
		],
		"description": "Returns the primary ammo type"
	},
	"string GetPrintName()": {
		"prefix": "GetPrintName",
		"body": [
			"GetPrintName()$0"
		],
		"description": "Gets the weapon's print name"
	},
	"int GetPropArraySize(handle entity, string propertyName)": {
		"prefix": "GetPropArraySize",
		"body": [
			"GetPropArraySize(${1:handle entity}, ${2:string propertyName})$0"
		],
		"description": "Returns the size of an netprop array, or -1."
	},
	"bool GetPropBool(handle entity, string propertyName)": {
		"prefix": "GetPropBool",
		"body": [
			"GetPropBool(${1:handle entity}, ${2:string propertyName})$0"
		],
		"description": "Reads a boolean-valued netprop."
	},
	"bool GetPropBoolArray(handle entity, string propertyName, int arrayElement)": {
		"prefix": "GetPropBoolArray",
		"body": [
			"GetPropBoolArray(${1:handle entity}, ${2:string propertyName}, ${3:int arrayElement})$0"
		],
		"description": "Reads a boolean-valued netprop from an array."
	},
	"handle GetPropEntity(handle entity, string propertyName)": {
		"prefix": "GetPropEntity",
		"body": [
			"GetPropEntity(${1:handle entity}, ${2:string propertyName})$0"
		],
		"description": "Reads an EHANDLE-valued netprop (21 bit integer). Returns the script handle of the entity."
	},
	"handle GetPropEntityArray(handle entity, string propertyName, int arrayElement)": {
		"prefix": "GetPropEntityArray",
		"body": [
			"GetPropEntityArray(${1:handle entity}, ${2:string propertyName}, ${3:int arrayElement})$0"
		],
		"description": "Reads an EHANDLE-valued netprop (21 bit integer) from an array. Returns the script handle of the entity."
	},
	"float GetPropFloat(handle entity, string propertyName)": {
		"prefix": "GetPropFloat",
		"body": [
			"GetPropFloat(${1:handle entity}, ${2:string propertyName})$0"
		],
		"description": "Reads a float-valued netprop."
	},
	"float GetPropFloatArray(handle entity, string propertyName, int arrayElement)": {
		"prefix": "GetPropFloatArray",
		"body": [
			"GetPropFloatArray(${1:handle entity}, ${2:string propertyName}, ${3:int arrayElement})$0"
		],
		"description": "Reads a float-valued netprop from an array."
	},
	"bool GetPropInfo(handle entity, string propertyName, int arrayElement, handle table)": {
		"prefix": "GetPropInfo",
		"body": [
			"GetPropInfo(${1:handle entity}, ${2:string propertyName}, ${3:int arrayElement}, ${4:handle table})$0"
		],
		"description": "Fills in a passed table with property info for the provided entity."
	},
	"int GetPropInt(handle entity, string propertyName)": {
		"prefix": "GetPropInt",
		"body": [
			"GetPropInt(${1:handle entity}, ${2:string propertyName})$0"
		],
		"description": "Reads an integer-valued netprop."
	},
	"int GetPropIntArray(handle entity, string propertyName, int arrayElement)": {
		"prefix": "GetPropIntArray",
		"body": [
			"GetPropIntArray(${1:handle entity}, ${2:string propertyName}, ${3:int arrayElement})$0"
		],
		"description": "Reads an integer-valued netprop from an array."
	},
	"string GetPropString(handle entity, string propertyName)": {
		"prefix": "GetPropString",
		"body": [
			"GetPropString(${1:handle entity}, ${2:string propertyName})$0"
		],
		"description": "Reads an string-valued netprop."
	},
	"string GetPropStringArray(handle entity, string propertyName, int arrayElement)": {
		"prefix": "GetPropStringArray",
		"body": [
			"GetPropStringArray(${1:handle entity}, ${2:string propertyName}, ${3:int arrayElement})$0"
		],
		"description": "Reads an string-valued netprop from an array."
	},
	"string GetPropType(handle entity, string propertyName)": {
		"prefix": "GetPropType",
		"body": [
			"GetPropType(${1:handle entity}, ${2:string propertyName})$0"
		],
		"description": "Returns the name of the netprop type as a string."
	},
	"Vector GetPropVector(handle entity, string propertyName)": {
		"prefix": "GetPropVector",
		"body": [
			"GetPropVector(${1:handle entity}, ${2:string propertyName})$0"
		],
		"description": "Reads a 3D vector-valued netprop."
	},
	"Vector GetPropVectorArray(handle entity, string propertyName, int arrayElement)": {
		"prefix": "GetPropVectorArray",
		"body": [
			"GetPropVectorArray(${1:handle entity}, ${2:string propertyName}, ${3:int arrayElement})$0"
		],
		"description": "Reads a 3D vector-valued netprop from an array."
	},
	"float GetRageMeter()": {
		"prefix": "GetRageMeter",
		"body": [
			"GetRageMeter()$0"
		],
		"description": ""
	},
	"handle GetRandomAdjacentArea(int dir)": {
		"prefix": "GetRandomAdjacentArea",
		"body": [
			"GetRandomAdjacentArea(${1:int dir})$0"
		],
		"description": "Return a random adjacent area in the given direction"
	},
	"int GetResupplyPoints()": {
		"prefix": "GetResupplyPoints",
		"body": [
			"GetResupplyPoints()$0"
		],
		"description": ""
	},
	"int GetRevenge()": {
		"prefix": "GetRevenge",
		"body": [
			"GetRevenge()$0"
		],
		"description": ""
	},
	"Vector GetRightVector()": {
		"prefix": "GetRightVector",
		"body": [
			"GetRightVector()$0"
		],
		"description": "Get the right vector of the entity"
	},
	"handle GetRootMoveParent()": {
		"prefix": "GetRootMoveParent",
		"body": [
			"GetRootMoveParent()$0"
		],
		"description": "If in hierarchy, walks up the hierarchy to find the root parent"
	},
	"int GetRoundState()": {
		"prefix": "GetRoundState",
		"body": [
			"GetRoundState()$0"
		],
		"description": "Get current round state. See Constants.ERoundState"
	},
	"float GetRunSpeed()": {
		"prefix": "GetRunSpeed",
		"body": [
			"GetRunSpeed()$0"
		],
		"description": "Get maximum running speed"
	},
	"float GetScoutHypeMeter()": {
		"prefix": "GetScoutHypeMeter",
		"body": [
			"GetScoutHypeMeter()$0"
		],
		"description": ""
	},
	"string GetScriptId()": {
		"prefix": "GetScriptId",
		"body": [
			"GetScriptId()$0"
		],
		"description": "Retrieve the unique identifier used to refer to the entity within the scripting system."
	},
	"string GetScriptOverlayMaterial()": {
		"prefix": "GetScriptOverlayMaterial",
		"body": [
			"GetScriptOverlayMaterial()$0"
		],
		"description": "Gets the current view overlay material"
	},
	"handle GetScriptScope()": {
		"prefix": "GetScriptScope",
		"body": [
			"GetScriptScope()$0"
		],
		"description": "Retrieve the script-side data associated with an entity"
	},
	"string GetScriptThinkFunc()": {
		"prefix": "GetScriptThinkFunc",
		"body": [
			"GetScriptThinkFunc()$0"
		],
		"description": "Retrieve the name of the current script think func"
	},
	"int GetSecondaryAmmoCount()": {
		"prefix": "GetSecondaryAmmoCount",
		"body": [
			"GetSecondaryAmmoCount()$0"
		],
		"description": "Current secondary ammo count if no clip is used or to give a player if they pick up this weapon legacy style (not TF)"
	},
	"int GetSecondaryAmmoType()": {
		"prefix": "GetSecondaryAmmoType",
		"body": [
			"GetSecondaryAmmoType()$0"
		],
		"description": "Returns the secondary ammo type"
	},
	"int GetSequence()": {
		"prefix": "GetSequence",
		"body": [
			"GetSequence()$0"
		],
		"description": "Get the current sequence id"
	},
	"string GetSequenceActivityName(int)": {
		"prefix": "GetSequenceActivityName",
		"body": [
			"GetSequenceActivityName(${1:int})$0"
		],
		"description": "Get the activity name for a sequence by id"
	},
	"float GetSequenceDuration(int)": {
		"prefix": "GetSequenceDuration",
		"body": [
			"GetSequenceDuration(${1:int})$0"
		],
		"description": "Get a sequence duration by id"
	},
	"string GetSequenceName(int)": {
		"prefix": "GetSequenceName",
		"body": [
			"GetSequenceName(${1:int})$0"
		],
		"description": "Get a sequence name by id"
	},
	"float GetSizeX()": {
		"prefix": "GetSizeX",
		"body": [
			"GetSizeX()$0"
		],
		"description": "Return the area size along the X axis"
	},
	"float GetSizeY()": {
		"prefix": "GetSizeY",
		"body": [
			"GetSizeY()$0"
		],
		"description": "Return the area size along the Y axis"
	},
	"int GetSkin()": {
		"prefix": "GetSkin",
		"body": [
			"GetSkin()$0"
		],
		"description": "Gets the current skin index."
	},
	"int GetSlot()": {
		"prefix": "GetSlot",
		"body": [
			"GetSlot()$0"
		],
		"description": "Gets the weapon's current slot"
	},
	"int GetSolid()": {
		"prefix": "GetSolid",
		"body": [
			"GetSolid()$0"
		],
		"description": ""
	},
	"float GetSoundDuration(string soundname, string actormodel)": {
		"prefix": "GetSoundDuration",
		"body": [
			"GetSoundDuration(${1:string soundname}, ${2:string actormodel})$0"
		],
		"description": "Returns float dur"
	},
	"handle GetSpawnArea()": {
		"prefix": "GetSpawnArea",
		"body": [
			"GetSpawnArea()$0"
		],
		"description": "Return the nav area of where we spawned"
	},
	"float GetSpeed()": {
		"prefix": "GetSpeed",
		"body": [
			"GetSpeed()$0"
		],
		"description": "Return current world space speed (magnitude of velocity)"
	},
	"float GetSpeedLimit()": {
		"prefix": "GetSpeedLimit",
		"body": [
			"GetSpeedLimit()$0"
		],
		"description": "Get maximum speed bot can reach, regardless of desired speed"
	},
	"float GetSpyCloakMeter()": {
		"prefix": "GetSpyCloakMeter",
		"body": [
			"GetSpyCloakMeter()$0"
		],
		"description": ""
	},
	"float GetSquadFormationError()": {
		"prefix": "GetSquadFormationError",
		"body": [
			"GetSquadFormationError()$0"
		],
		"description": "Gets our formation error coefficient."
	},
	"float GetStepHeight()": {
		"prefix": "GetStepHeight",
		"body": [
			"GetStepHeight()$0"
		],
		"description": "If delta Z is greater than this, we have to jump to get up"
	},
	"int GetStopWatchState()": {
		"prefix": "GetStopWatchState",
		"body": [
			"GetStopWatchState()$0"
		],
		"description": "Get the current stopwatch state. See Constants.EStopwatchState"
	},
	"string GetStr(string name)": {
		"prefix": "GetStr",
		"body": [
			"GetStr(${1:string name})$0"
		],
		"description": "Returns the convar as a string. May return null if no such convar."
	},
	"float GetStuckDuration()": {
		"prefix": "GetStuckDuration",
		"body": [
			"GetStuckDuration()$0"
		],
		"description": "Return how long we've been stuck"
	},
	"int GetSubType()": {
		"prefix": "GetSubType",
		"body": [
			"GetSubType()$0"
		],
		"description": "Get the weapon subtype"
	},
	"void GetTable(handle entity, int iPropType, handle table)": {
		"prefix": "GetTable",
		"body": [
			"GetTable(${1:handle entity}, ${2:int iPropType}, ${3:handle table})$0"
		],
		"description": "Fills in a passed table with all props of a specified type for the provided entity (set iPropType to 0 for SendTable or 1 for DataMap)"
	},
	"int GetTeam()": {
		"prefix": "GetTeam",
		"body": [
			"GetTeam()$0"
		],
		"description": ""
	},
	"int GetTeleports()": {
		"prefix": "GetTeleports",
		"body": [
			"GetTeleports()$0"
		],
		"description": ""
	},
	"int GetTickLastUpdate()": {
		"prefix": "GetTickLastUpdate",
		"body": [
			"GetTickLastUpdate()$0"
		],
		"description": "Get last update tick"
	},
	"float GetTimeSinceCalledForMedic()": {
		"prefix": "GetTimeSinceCalledForMedic",
		"body": [
			"GetTimeSinceCalledForMedic()$0"
		],
		"description": "When did the player last call medic"
	},
	"float GetTravelDistanceToBombTarget()": {
		"prefix": "GetTravelDistanceToBombTarget",
		"body": [
			"GetTravelDistanceToBombTarget()$0"
		],
		"description": "Gets the travel distance to the MvM bomb target"
	},
	"float GetTraversableSlopeLimit()": {
		"prefix": "GetTraversableSlopeLimit",
		"body": [
			"GetTraversableSlopeLimit()$0"
		],
		"description": "Return Z component of unit normal of steepest traversable slope"
	},
	"Vector GetUpVector()": {
		"prefix": "GetUpVector",
		"body": [
			"GetUpVector()$0"
		],
		"description": "Get the up vector of the entity"
	},
	"float GetUpdateInterval()": {
		"prefix": "GetUpdateInterval",
		"body": [
			"GetUpdateInterval()$0"
		],
		"description": "Returns the component update interval"
	},
	"Vector GetVelocity()": {
		"prefix": "GetVelocity",
		"body": [
			"GetVelocity()$0"
		],
		"description": "Return current world space velocity"
	},
	"handle GetVisionInterface()": {
		"prefix": "GetVisionInterface",
		"body": [
			"GetVisionInterface()$0"
		],
		"description": "Get this bot's vision interface"
	},
	"float GetWalkSpeed()": {
		"prefix": "GetWalkSpeed",
		"body": [
			"GetWalkSpeed()$0"
		],
		"description": "Get maximum walking speed"
	},
	"int GetWaterLevel()": {
		"prefix": "GetWaterLevel",
		"body": [
			"GetWaterLevel()$0"
		],
		"description": ""
	},
	"int GetWaterType()": {
		"prefix": "GetWaterType",
		"body": [
			"GetWaterType()$0"
		],
		"description": ""
	},
	"int GetWeaponFlags()": {
		"prefix": "GetWeaponFlags",
		"body": [
			"GetWeaponFlags()$0"
		],
		"description": "Get the weapon flags"
	},
	"int GetWeight()": {
		"prefix": "GetWeight",
		"body": [
			"GetWeight()$0"
		],
		"description": "Get the weapon weighting/importance"
	},
	"int GetWinningTeam()": {
		"prefix": "GetWinningTeam",
		"body": [
			"GetWinningTeam()$0"
		],
		"description": "Who won!"
	},
	"float GetZ(Vector pos)": {
		"prefix": "GetZ",
		"body": [
			"GetZ(${1:Vector pos})$0"
		],
		"description": "Return Z of area at (x,y) of 'pos'"
	},
	"bool HasAction(handle entity, string outputName)": {
		"prefix": "HasAction",
		"body": [
			"HasAction(${1:handle entity}, ${2:string outputName})$0"
		],
		"description": "Returns true if an action exists for the output."
	},
	"bool HasAnyAmmo()": {
		"prefix": "HasAnyAmmo",
		"body": [
			"HasAnyAmmo()$0"
		],
		"description": "Do we have any ammo?"
	},
	"bool HasAttributeTF(int)": {
		"prefix": "HasAttributeTF",
		"body": [
			"HasAttributeTF(${1:int})$0"
		],
		"description": "Has TF-specific area attribute bits"
	},
	"bool HasAttributes(int)": {
		"prefix": "HasAttributes",
		"body": [
			"HasAttributes(${1:int})$0"
		],
		"description": "Has area attribute bits"
	},
	"bool HasAvoidanceObstacle(float maxheight)": {
		"prefix": "HasAvoidanceObstacle",
		"body": [
			"HasAvoidanceObstacle(${1:float maxheight})$0"
		],
		"description": "Returns true if there's a large, immobile object obstructing this area"
	},
	"bool HasBotAttribute(int)": {
		"prefix": "HasBotAttribute",
		"body": [
			"HasBotAttribute(${1:int})$0"
		],
		"description": "Checks if this TFBot has the given attributes"
	},
	"bool HasBotTag(string)": {
		"prefix": "HasBotTag",
		"body": [
			"HasBotTag(${1:string})$0"
		],
		"description": "Checks if this TFBot has the given bot tag"
	},
	"bool HasItem()": {
		"prefix": "HasItem",
		"body": [
			"HasItem()$0"
		],
		"description": "Currently holding an item? Eg. capture flag"
	},
	"bool HasOutput(handle entity, string outputName)": {
		"prefix": "HasOutput",
		"body": [
			"HasOutput(${1:handle entity}, ${2:string outputName})$0"
		],
		"description": "Returns true if the output exists."
	},
	"float HasPotentialGap(Vector, Vector)": {
		"prefix": "HasPotentialGap",
		"body": [
			"HasPotentialGap(${1:Vector}, ${2:Vector})$0"
		],
		"description": "Return true if there is a possible gap that will need to be jumped over"
	},
	"bool HasPrimaryAmmo()": {
		"prefix": "HasPrimaryAmmo",
		"body": [
			"HasPrimaryAmmo()$0"
		],
		"description": "Do we have any primary ammo?"
	},
	"bool HasProp(handle entity, string propertyName)": {
		"prefix": "HasProp",
		"body": [
			"HasProp(${1:handle entity}, ${2:string propertyName})$0"
		],
		"description": "Checks if a netprop exists."
	},
	"bool HasSecondaryAmmo()": {
		"prefix": "HasSecondaryAmmo",
		"body": [
			"HasSecondaryAmmo()$0"
		],
		"description": "Do we have any secondary ammo?"
	},
	"bool HasWeaponRestriction(int)": {
		"prefix": "HasWeaponRestriction",
		"body": [
			"HasWeaponRestriction(${1:int})$0"
		],
		"description": "Checks if this TFBot has the given weapon restriction flags"
	},
	"bool HaveStopWatchWinner()": {
		"prefix": "HaveStopWatchWinner",
		"body": [
			"HaveStopWatchWinner()$0"
		],
		"description": ""
	},
	"HookRootMetamethod()": {
		"prefix": "HookRootMetamethod",
		"body": [
			"HookRootMetamethod()$0"
		],
		"description": ""
	},
	"void IgnitePlayer()": {
		"prefix": "IgnitePlayer",
		"body": [
			"IgnitePlayer()$0"
		],
		"description": ""
	},
	"bool InAirDueToExplosion()": {
		"prefix": "InAirDueToExplosion",
		"body": [
			"InAirDueToExplosion()$0"
		],
		"description": ""
	},
	"bool InAirDueToKnockback()": {
		"prefix": "InAirDueToKnockback",
		"body": [
			"InAirDueToKnockback()$0"
		],
		"description": ""
	},
	"bool InCond(ETFCond cond)": {
		"prefix": "InCond",
		"body": [
			"InCond(${1:ETFCond cond})$0"
		],
		"description": ""
	},
	"bool InMatchStartCountdown()": {
		"prefix": "InMatchStartCountdown",
		"body": [
			"InMatchStartCountdown()$0"
		],
		"description": "Are we in the pre-match state?"
	},
	"bool InOvertime()": {
		"prefix": "InOvertime",
		"body": [
			"InOvertime()$0"
		],
		"description": "Currently in overtime?"
	},
	"bool IncludeScript(string file, handle scope = null)": {
		"prefix": "IncludeScript",
		"body": [
			"IncludeScript(${1:string file}, ${2:handle scope = null})$0"
		],
		"description": "Wrapper for DoIncludeScript"
	},
	"Quaternion Invert()": {
		"prefix": "Invert",
		"body": [
			"Invert()$0"
		],
		"description": "Returns a quaternion with the complimentary rotation."
	},
	"bool IsAbleToClimb()": {
		"prefix": "IsAbleToClimb",
		"body": [
			"IsAbleToClimb()$0"
		],
		"description": "Return true if this bot can climb arbitrary geometry it encounters"
	},
	"bool IsAbleToJumpAcrossGaps()": {
		"prefix": "IsAbleToJumpAcrossGaps",
		"body": [
			"IsAbleToJumpAcrossGaps()$0"
		],
		"description": "Return true if this bot can jump across gaps in its path"
	},
	"bool IsAirDashing()": {
		"prefix": "IsAirDashing",
		"body": [
			"IsAirDashing()$0"
		],
		"description": ""
	},
	"bool IsAllowedToSwitch()": {
		"prefix": "IsAllowedToSwitch",
		"body": [
			"IsAllowedToSwitch()$0"
		],
		"description": "Are we allowed to switch to this weapon?"
	},
	"bool IsAllowedToTaunt()": {
		"prefix": "IsAllowedToTaunt",
		"body": [
			"IsAllowedToTaunt()$0"
		],
		"description": ""
	},
	"bool IsAmmoFull()": {
		"prefix": "IsAmmoFull",
		"body": [
			"IsAmmoFull()$0"
		],
		"description": ""
	},
	"bool IsAmmoLow()": {
		"prefix": "IsAmmoLow",
		"body": [
			"IsAmmoLow()$0"
		],
		"description": ""
	},
	"bool IsAreaTraversable(handle)": {
		"prefix": "IsAreaTraversable",
		"body": [
			"IsAreaTraversable(${1:handle})$0"
		],
		"description": "Return true if given area can be used for navigation"
	},
	"bool IsAttackDefenseMode()": {
		"prefix": "IsAttackDefenseMode",
		"body": [
			"IsAttackDefenseMode()$0"
		],
		"description": ""
	},
	"bool IsAttemptingToMove()": {
		"prefix": "IsAttemptingToMove",
		"body": [
			"IsAttemptingToMove()$0"
		],
		"description": "Return true if we have tried to Approach() or DriveTo() very recently"
	},
	"bool IsAttentionFocused()": {
		"prefix": "IsAttentionFocused",
		"body": [
			"IsAttentionFocused()$0"
		],
		"description": "Is our attention focused right now?"
	},
	"bool IsAttentionFocusedOn(handle)": {
		"prefix": "IsAttentionFocusedOn",
		"body": [
			"IsAttentionFocusedOn(${1:handle})$0"
		],
		"description": "Is our attention focused on this entity"
	},
	"bool IsBirthday()": {
		"prefix": "IsBirthday",
		"body": [
			"IsBirthday()$0"
		],
		"description": "Are we in birthday mode?"
	},
	"bool IsBlocked(int team, bool)": {
		"prefix": "IsBlocked",
		"body": [
			"IsBlocked(${1:int team}, ${2:bool})$0"
		],
		"description": "Return true if team is blocked in this area"
	},
	"bool IsBottleneck()": {
		"prefix": "IsBottleneck",
		"body": [
			"IsBottleneck()$0"
		],
		"description": "Returns true if area is a bottleneck"
	},
	"bool IsCallingForMedic()": {
		"prefix": "IsCallingForMedic",
		"body": [
			"IsCallingForMedic()$0"
		],
		"description": "Is this player calling for medic?"
	},
	"bool IsCarryingRune()": {
		"prefix": "IsCarryingRune",
		"body": [
			"IsCarryingRune()$0"
		],
		"description": ""
	},
	"bool IsClimbingOrJumping()": {
		"prefix": "IsClimbingOrJumping",
		"body": [
			"IsClimbingOrJumping()$0"
		],
		"description": "Is jumping in any form"
	},
	"bool IsClimbingUpToLedge()": {
		"prefix": "IsClimbingUpToLedge",
		"body": [
			"IsClimbingUpToLedge()$0"
		],
		"description": "Is climbing up to a high ledge"
	},
	"bool IsCompetitiveMode()": {
		"prefix": "IsCompetitiveMode",
		"body": [
			"IsCompetitiveMode()$0"
		],
		"description": "Playing competitive?"
	},
	"bool IsCompletelyVisibleToTeam(int team)": {
		"prefix": "IsCompletelyVisibleToTeam",
		"body": [
			"IsCompletelyVisibleToTeam(${1:int team})$0"
		],
		"description": "Return true if given area is completely visible from somewhere in this area by someone on the team"
	},
	"bool IsConVarOnAllowList(string name)": {
		"prefix": "IsConVarOnAllowList",
		"body": [
			"IsConVarOnAllowList(${1:string name})$0"
		],
		"description": "Checks if the convar is allowed to be used and is in cfg/vscript_convar_allowlist.txt. Please be nice with this and use it for *compatibility* if you need check support and NOT to force server owners to allow hostname to be set... or else this will simply lie and return true in future. ;-) You have been warned!"
	},
	"bool IsConnected(handle area, int dir)": {
		"prefix": "IsConnected",
		"body": [
			"IsConnected(${1:handle area}, ${2:int dir})$0"
		],
		"description": "Return true if given area is connected in given direction"
	},
	"bool IsControlStunned()": {
		"prefix": "IsControlStunned",
		"body": [
			"IsControlStunned()$0"
		],
		"description": ""
	},
	"bool IsCoplanar(handle area)": {
		"prefix": "IsCoplanar",
		"body": [
			"IsCoplanar(${1:handle area})$0"
		],
		"description": "Return true if this area and given area are approximately co-planar"
	},
	"bool IsCritBoosted()": {
		"prefix": "IsCritBoosted",
		"body": [
			"IsCritBoosted()$0"
		],
		"description": ""
	},
	"bool IsDamaging()": {
		"prefix": "IsDamaging",
		"body": [
			"IsDamaging()$0"
		],
		"description": "Return true if continuous damage (ie: fire) is in this area"
	},
	"bool IsDedicatedServer()": {
		"prefix": "IsDedicatedServer",
		"body": [
			"IsDedicatedServer()$0"
		],
		"description": "Returns true if this server is a dedicated server."
	},
	"bool IsDefaultGameMode()": {
		"prefix": "IsDefaultGameMode",
		"body": [
			"IsDefaultGameMode()$0"
		],
		"description": "The absence of arena, mvm, tournament mode, etc"
	},
	"bool IsDegenerate()": {
		"prefix": "IsDegenerate",
		"body": [
			"IsDegenerate()$0"
		],
		"description": "Return true if this area is badly formed"
	},
	"bool IsDifficulty(int)": {
		"prefix": "IsDifficulty",
		"body": [
			"IsDifficulty(${1:int})$0"
		],
		"description": "Returns true/false if the bot's difficulty level matches."
	},
	"bool IsEFlagSet(int)": {
		"prefix": "IsEFlagSet",
		"body": [
			"IsEFlagSet(${1:int})$0"
		],
		"description": ""
	},
	"bool IsEdge(int dir)": {
		"prefix": "IsEdge",
		"body": [
			"IsEdge(${1:int dir})$0"
		],
		"description": "Return true if there are no bi-directional links on the given side"
	},
	"bool IsEnemy(handle)": {
		"prefix": "IsEnemy",
		"body": [
			"IsEnemy(${1:handle})$0"
		],
		"description": "Return true if given entity is our enemy"
	},
	"bool IsEntityTraversable(handle, bool)": {
		"prefix": "IsEntityTraversable",
		"body": [
			"IsEntityTraversable(${1:handle}, ${2:bool})$0"
		],
		"description": "Return true if the entity handle is traversable"
	},
	"bool IsFireproof()": {
		"prefix": "IsFireproof",
		"body": [
			"IsFireproof()$0"
		],
		"description": ""
	},
	"bool IsFlaggedForUpdate()": {
		"prefix": "IsFlaggedForUpdate",
		"body": [
			"IsFlaggedForUpdate()$0"
		],
		"description": "Is this bot flagged for update"
	},
	"bool IsFlat()": {
		"prefix": "IsFlat",
		"body": [
			"IsFlat()$0"
		],
		"description": "Return true if this area is approximately flat"
	},
	"bool IsFriend(handle)": {
		"prefix": "IsFriend",
		"body": [
			"IsFriend(${1:handle})$0"
		],
		"description": "Return true if given entity is our friend"
	},
	"bool IsFullyInvisible()": {
		"prefix": "IsFullyInvisible",
		"body": [
			"IsFullyInvisible()$0"
		],
		"description": ""
	},
	"bool IsGap(Vector, Vector)": {
		"prefix": "IsGap",
		"body": [
			"IsGap(${1:Vector}, ${2:Vector})$0"
		],
		"description": "Return true if there is a gap here when moving in the given direction"
	},
	"bool IsHolidayActive(int holiday)": {
		"prefix": "IsHolidayActive",
		"body": [
			"IsHolidayActive(${1:int holiday})$0"
		],
		"description": "Is the given holiday active? See Constants.EHoliday"
	},
	"bool IsHolidayMap(int holiday)": {
		"prefix": "IsHolidayMap",
		"body": [
			"IsHolidayMap(${1:int holiday})$0"
		],
		"description": "Playing a holiday map? See Constants.EHoliday"
	},
	"bool IsHypeBuffed()": {
		"prefix": "IsHypeBuffed",
		"body": [
			"IsHypeBuffed()$0"
		],
		"description": ""
	},
	"bool IsImmobile()": {
		"prefix": "IsImmobile",
		"body": [
			"IsImmobile()$0"
		],
		"description": "Return true if we haven't moved in awhile"
	},
	"bool IsImmuneToPushback()": {
		"prefix": "IsImmuneToPushback",
		"body": [
			"IsImmuneToPushback()$0"
		],
		"description": ""
	},
	"bool IsInASquad()": {
		"prefix": "IsInASquad",
		"body": [
			"IsInASquad()$0"
		],
		"description": "Checks if we are in a squad"
	},
	"bool IsInArenaMode()": {
		"prefix": "IsInArenaMode",
		"body": [
			"IsInArenaMode()$0"
		],
		"description": "Playing arena mode?"
	},
	"bool IsInKothMode()": {
		"prefix": "IsInKothMode",
		"body": [
			"IsInKothMode()$0"
		],
		"description": "Playing king of the hill mode?"
	},
	"bool IsInMedievalMode()": {
		"prefix": "IsInMedievalMode",
		"body": [
			"IsInMedievalMode()$0"
		],
		"description": "Playing medieval mode?"
	},
	"bool IsInWaitingForPlayers()": {
		"prefix": "IsInWaitingForPlayers",
		"body": [
			"IsInWaitingForPlayers()$0"
		],
		"description": "Are we waiting for some stragglers?"
	},
	"bool IsInspecting()": {
		"prefix": "IsInspecting",
		"body": [
			"IsInspecting()$0"
		],
		"description": ""
	},
	"bool IsInvulnerable()": {
		"prefix": "IsInvulnerable",
		"body": [
			"IsInvulnerable()$0"
		],
		"description": ""
	},
	"bool IsJumping()": {
		"prefix": "IsJumping",
		"body": [
			"IsJumping()$0"
		],
		"description": ""
	},
	"bool IsJumpingAcrossGap()": {
		"prefix": "IsJumpingAcrossGap",
		"body": [
			"IsJumpingAcrossGap()$0"
		],
		"description": "Is jumping across a gap to the far side"
	},
	"bool IsKeyEmpty(string key)": {
		"prefix": "IsKeyEmpty",
		"body": [
			"IsKeyEmpty(${1:string key})$0"
		],
		"description": "Returns true if the named key has no value."
	},
	"bool IsMannVsMachineMode()": {
		"prefix": "IsMannVsMachineMode",
		"body": [
			"IsMannVsMachineMode()$0"
		],
		"description": "Playing MvM? Beep boop"
	},
	"bool IsMannVsMachineRespecEnabled()": {
		"prefix": "IsMannVsMachineRespecEnabled",
		"body": [
			"IsMannVsMachineRespecEnabled()$0"
		],
		"description": "Are players allowed to refund their upgrades?"
	},
	"bool IsMatchTypeCasual()": {
		"prefix": "IsMatchTypeCasual",
		"body": [
			"IsMatchTypeCasual()$0"
		],
		"description": "Playing casual?"
	},
	"bool IsMatchTypeCompetitive()": {
		"prefix": "IsMatchTypeCompetitive",
		"body": [
			"IsMatchTypeCompetitive()$0"
		],
		"description": "Playing competitive?"
	},
	"bool IsMeleeWeapon()": {
		"prefix": "IsMeleeWeapon",
		"body": [
			"IsMeleeWeapon()$0"
		],
		"description": "Returns whether this is a melee weapon"
	},
	"bool IsMiniBoss()": {
		"prefix": "IsMiniBoss",
		"body": [
			"IsMiniBoss()$0"
		],
		"description": "Is this player an MvM mini-boss?"
	},
	"bool IsModelPrecached(string modelname)": {
		"prefix": "IsModelPrecached",
		"body": [
			"IsModelPrecached(${1:string modelname})$0"
		],
		"description": "Checks if the modelname is precached."
	},
	"bool IsNoclipping()": {
		"prefix": "IsNoclipping",
		"body": [
			"IsNoclipping()$0"
		],
		"description": "Returns true if the player is in noclip mode."
	},
	"bool IsOnGround()": {
		"prefix": "IsOnGround",
		"body": [
			"IsOnGround()$0"
		],
		"description": "Return true if standing on something"
	},
	"bool IsOverlapping(handle area)": {
		"prefix": "IsOverlapping",
		"body": [
			"IsOverlapping(${1:handle area})$0"
		],
		"description": "Return true if 'area' overlaps our 2D extents"
	},
	"bool IsOverlappingOrigin(Vector pos, float tolerance)": {
		"prefix": "IsOverlappingOrigin",
		"body": [
			"IsOverlappingOrigin(${1:Vector pos}, ${2:float tolerance})$0"
		],
		"description": "Return true if 'pos' is within 2D extents of area"
	},
	"bool IsPVEModeActive()": {
		"prefix": "IsPVEModeActive",
		"body": [
			"IsPVEModeActive()$0"
		],
		"description": ""
	},
	"bool IsParachuteEquipped()": {
		"prefix": "IsParachuteEquipped",
		"body": [
			"IsParachuteEquipped()$0"
		],
		"description": ""
	},
	"bool IsPasstimeMode()": {
		"prefix": "IsPasstimeMode",
		"body": [
			"IsPasstimeMode()$0"
		],
		"description": "No ball games."
	},
	"bool IsPaused()": {
		"prefix": "IsPaused",
		"body": [
			"IsPaused()$0"
		],
		"description": "If this scene is currently paused."
	},
	"bool IsPlacingSapper()": {
		"prefix": "IsPlacingSapper",
		"body": [
			"IsPlacingSapper()$0"
		],
		"description": "Returns true if we placed a sapper in the last few moments"
	},
	"IsPlayer()": {
		"prefix": "IsPlayer",
		"body": [
			"IsPlayer()$0"
		],
		"description": ""
	},
	"bool IsPlayerABot(handle player)": {
		"prefix": "IsPlayerABot",
		"body": [
			"IsPlayerABot(${1:handle player})$0"
		],
		"description": "Is this player/entity a bot."
	},
	"bool IsPlayerSpeaking(int)": {
		"prefix": "IsPlayerSpeaking",
		"body": [
			"IsPlayerSpeaking(${1:int})$0"
		],
		"description": "Returns whether the player specified is speaking."
	},
	"bool IsPlayingBack()": {
		"prefix": "IsPlayingBack",
		"body": [
			"IsPlayingBack()$0"
		],
		"description": "If this scene is currently playing."
	},
	"float IsPotentiallyTraversable(Vector, Vector, bool)": {
		"prefix": "IsPotentiallyTraversable",
		"body": [
			"IsPotentiallyTraversable(${1:Vector}, ${2:Vector}, ${3:bool})$0"
		],
		"description": "Return true if this locomotor could potentially move along the line given."
	},
	"bool IsPotentiallyVisibleToTeam(int team)": {
		"prefix": "IsPotentiallyVisibleToTeam",
		"body": [
			"IsPotentiallyVisibleToTeam(${1:int team})$0"
		],
		"description": "Return true if any portion of this area is visible to anyone on the given team"
	},
	"bool IsPowerupMode()": {
		"prefix": "IsPowerupMode",
		"body": [
			"IsPowerupMode()$0"
		],
		"description": "Playing powerup mode? Not compatible with MvM"
	},
	"bool IsQuickBuildTime()": {
		"prefix": "IsQuickBuildTime",
		"body": [
			"IsQuickBuildTime()$0"
		],
		"description": "If an engie places a building, will it immediately upgrade? Eg. MvM pre-round etc."
	},
	"bool IsRageDraining()": {
		"prefix": "IsRageDraining",
		"body": [
			"IsRageDraining()$0"
		],
		"description": ""
	},
	"bool IsReachableByTeam(int)": {
		"prefix": "IsReachableByTeam",
		"body": [
			"IsReachableByTeam(${1:int})$0"
		],
		"description": "Is this area reachable by the given team?"
	},
	"bool IsRegenerating()": {
		"prefix": "IsRegenerating",
		"body": [
			"IsRegenerating()$0"
		],
		"description": ""
	},
	"bool IsRoughlySquare()": {
		"prefix": "IsRoughlySquare",
		"body": [
			"IsRoughlySquare()$0"
		],
		"description": "Return true if this area is approximately square"
	},
	"bool IsRunning()": {
		"prefix": "IsRunning",
		"body": [
			"IsRunning()$0"
		],
		"description": "Is running?"
	},
	"bool IsSapping()": {
		"prefix": "IsSapping",
		"body": [
			"IsSapping()$0"
		],
		"description": "Returns true if we are currently sapping"
	},
	"bool IsScrambling()": {
		"prefix": "IsScrambling",
		"body": [
			"IsScrambling()$0"
		],
		"description": "Is in the middle of a complex action (climbing a ladder, climbing a ledge, jumping, etc) that shouldn't be interrupted"
	},
	"bool IsSequenceFinished()": {
		"prefix": "IsSequenceFinished",
		"body": [
			"IsSequenceFinished()$0"
		],
		"description": "Ask whether the main sequence is done playing"
	},
	"bool IsSnared()": {
		"prefix": "IsSnared",
		"body": [
			"IsSnared()$0"
		],
		"description": ""
	},
	"bool IsSolid()": {
		"prefix": "IsSolid",
		"body": [
			"IsSolid()$0"
		],
		"description": ""
	},
	"bool IsSolidFlagSet(int)": {
		"prefix": "IsSolidFlagSet",
		"body": [
			"IsSolidFlagSet(${1:int})$0"
		],
		"description": ""
	},
	"bool IsSoundPrecached(string soundname)": {
		"prefix": "IsSoundPrecached",
		"body": [
			"IsSoundPrecached(${1:string soundname})$0"
		],
		"description": "Checks if the soundname is precached."
	},
	"bool IsStealthed()": {
		"prefix": "IsStealthed",
		"body": [
			"IsStealthed()$0"
		],
		"description": ""
	},
	"bool IsStuck()": {
		"prefix": "IsStuck",
		"body": [
			"IsStuck()$0"
		],
		"description": "Return true if bot is stuck. If the locomotor cannot make progress, it becomes stuck and can only leave this stuck state by successfully movingand becoming un-stuck."
	},
	"bool IsTFMarked()": {
		"prefix": "IsTFMarked",
		"body": [
			"IsTFMarked()$0"
		],
		"description": "Is this nav area marked with the current marking scope?"
	},
	"bool IsTruceActive()": {
		"prefix": "IsTruceActive",
		"body": [
			"IsTruceActive()$0"
		],
		"description": ""
	},
	"bool IsUnderwater()": {
		"prefix": "IsUnderwater",
		"body": [
			"IsUnderwater()$0"
		],
		"description": "Return true if area is underwater"
	},
	"bool IsUsingActionSlot()": {
		"prefix": "IsUsingActionSlot",
		"body": [
			"IsUsingActionSlot()$0"
		],
		"description": ""
	},
	"bool IsUsingGrapplingHook()": {
		"prefix": "IsUsingGrapplingHook",
		"body": [
			"IsUsingGrapplingHook()$0"
		],
		"description": ""
	},
	"bool IsUsingSpells()": {
		"prefix": "IsUsingSpells",
		"body": [
			"IsUsingSpells()$0"
		],
		"description": ""
	},
	"IsValid()": {
		"prefix": "IsValid",
		"body": [
			"IsValid()$0"
		],
		"description": ""
	},
	"bool IsValidForWanderingPopulation()": {
		"prefix": "IsValidForWanderingPopulation",
		"body": [
			"IsValidForWanderingPopulation()$0"
		],
		"description": "Returns true if area is valid for wandering population"
	},
	"bool IsViewingCYOAPDA()": {
		"prefix": "IsViewingCYOAPDA",
		"body": [
			"IsViewingCYOAPDA()$0"
		],
		"description": ""
	},
	"bool IsVisible(Vector point)": {
		"prefix": "IsVisible",
		"body": [
			"IsVisible(${1:Vector point})$0"
		],
		"description": "Return true if area is visible from the given eyepoint"
	},
	"bool IsWeakref()": {
		"prefix": "IsWeakref",
		"body": [
			"IsWeakref()$0"
		],
		"description": ""
	},
	"bool IsWeaponRestricted(handle)": {
		"prefix": "IsWeaponRestricted",
		"body": [
			"IsWeaponRestricted(${1:handle})$0"
		],
		"description": "Checks if the given weapon is restricted for use on the bot"
	},
	"void Jump()": {
		"prefix": "Jump",
		"body": [
			"Jump()$0"
		],
		"description": "Initiate a simple undirected jump in the air"
	},
	"void JumpAcrossGap(Vector, Vector)": {
		"prefix": "JumpAcrossGap",
		"body": [
			"JumpAcrossGap(${1:Vector}, ${2:Vector})$0"
		],
		"description": "Initiate a jump across an empty volume of space to far side"
	},
	"bool KeyValueFromFloat(string, float)": {
		"prefix": "KeyValueFromFloat",
		"body": [
			"KeyValueFromFloat(${1:string}, ${2:float})$0"
		],
		"description": "Executes KeyValue with a float"
	},
	"bool KeyValueFromInt(string, int)": {
		"prefix": "KeyValueFromInt",
		"body": [
			"KeyValueFromInt(${1:string}, ${2:int})$0"
		],
		"description": "Executes KeyValue with an int"
	},
	"bool KeyValueFromString(string, string)": {
		"prefix": "KeyValueFromString",
		"body": [
			"KeyValueFromString(${1:string}, ${2:string})$0"
		],
		"description": "Executes KeyValue with a string"
	},
	"bool KeyValueFromVector(string, Vector)": {
		"prefix": "KeyValueFromVector",
		"body": [
			"KeyValueFromVector(${1:string}, ${2:Vector})$0"
		],
		"description": "Executes KeyValue with a vector"
	},
	"void Kill()": {
		"prefix": "Kill",
		"body": [
			"Kill()$0"
		],
		"description": ""
	},
	"void LeaveSquad()": {
		"prefix": "LeaveSquad",
		"body": [
			"LeaveSquad()$0"
		],
		"description": "Makes us leave the current squad (if any)"
	},
	"Left()": {
		"prefix": "Left",
		"body": [
			"Left()$0"
		],
		"description": ""
	},
	"float Length()": {
		"prefix": "Length",
		"body": [
			"Length()$0"
		],
		"description": "Magnitude of the vector."
	},
	"float Length2D()": {
		"prefix": "Length2D",
		"body": [
			"Length2D()$0"
		],
		"description": "Returns the magnitude of the vector on the x-y plane. Meant to be used when working with the client's HUD."
	},
	"float Length2DSqr()": {
		"prefix": "Length2DSqr",
		"body": [
			"Length2DSqr()$0"
		],
		"description": "Returns the square of the magnitude of the vector on the x-y plane. Faster than the above method."
	},
	"float LengthSqr()": {
		"prefix": "LengthSqr",
		"body": [
			"LengthSqr()$0"
		],
		"description": "The magnitude of the vector squared. Faster than the above method."
	},
	"bool LoadSceneFromString(string, string)": {
		"prefix": "LoadSceneFromString",
		"body": [
			"LoadSceneFromString(${1:string}, ${2:string})$0"
		],
		"description": "given a dummy scene name and a vcd string, load the scene"
	},
	"handle LocalEyeAngles()": {
		"prefix": "LocalEyeAngles",
		"body": [
			"LocalEyeAngles()$0"
		],
		"description": "Returns the entity's local eye angles"
	},
	"void LocalTime(table)": {
		"prefix": "LocalTime",
		"body": [
			"LocalTime(${1:table})$0"
		],
		"description": "Fills out a table with the local time (second, minute, hour, day, month, year, dayofweek, dayofyear, daylightsavings)"
	},
	"Log()": {
		"prefix": "Log",
		"body": [
			"Log()$0"
		],
		"description": ""
	},
	"int LookupActivity(string)": {
		"prefix": "LookupActivity",
		"body": [
			"LookupActivity(${1:string})$0"
		],
		"description": "Get the named activity index"
	},
	"int LookupAttachment(string)": {
		"prefix": "LookupAttachment",
		"body": [
			"LookupAttachment(${1:string})$0"
		],
		"description": "Get the named attachement id"
	},
	"int LookupBone(string)": {
		"prefix": "LookupBone",
		"body": [
			"LookupBone(${1:string})$0"
		],
		"description": "Get the named bone index"
	},
	"int LookupPoseParameter(string)": {
		"prefix": "LookupPoseParameter",
		"body": [
			"LookupPoseParameter(${1:string})$0"
		],
		"description": "Looks up a pose parameter index by name"
	},
	"int LookupSequence(string)": {
		"prefix": "LookupSequence",
		"body": [
			"LookupSequence(${1:string})$0"
		],
		"description": "Looks up a sequence by sequence name or activity name"
	},
	"MakeNamespace()": {
		"prefix": "MakeNamespace",
		"body": [
			"MakeNamespace()$0"
		],
		"description": ""
	},
	"bool MapHasMatchSummaryStage()": {
		"prefix": "MapHasMatchSummaryStage",
		"body": [
			"MapHasMatchSummaryStage()$0"
		],
		"description": ""
	},
	"void MarkAsBlocked(int team)": {
		"prefix": "MarkAsBlocked",
		"body": [
			"MarkAsBlocked(${1:int team})$0"
		],
		"description": "Mark this area as blocked for team"
	},
	"void MarkAsDamaging(float duration)": {
		"prefix": "MarkAsDamaging",
		"body": [
			"MarkAsDamaging(${1:float duration})$0"
		],
		"description": "Mark this area is damaging for the next 'duration' seconds"
	},
	"void MarkObstacleToAvoid(float height)": {
		"prefix": "MarkObstacleToAvoid",
		"body": [
			"MarkObstacleToAvoid(${1:float height})$0"
		],
		"description": "Marks the obstructed status of the nav area"
	},
	"bool MatchmakingShouldUseStopwatchMode()": {
		"prefix": "MatchmakingShouldUseStopwatchMode",
		"body": [
			"MatchmakingShouldUseStopwatchMode()$0"
		],
		"description": ""
	},
	"void Msg(string message)": {
		"prefix": "Msg",
		"body": [
			"Msg(${1:string message})$0"
		],
		"description": "Prints message to console without any line feed after."
	},
	"bool NavAreaBuildPath(CTFNavArea startArea, CTFNavArea endArea, Vector goalPos, float flMaxPathLength, int teamID, bool ignoreNavBlockers)": {
		"prefix": "NavAreaBuildPath",
		"body": [
			"NavAreaBuildPath(${1:CTFNavArea startArea}, ${2:CTFNavArea endArea}, ${3:Vector goalPos}, ${4:float flMaxPathLength}, ${5:int teamID}, ${6:bool ignoreNavBlockers})$0"
		],
		"description": "returns true if a path exists"
	},
	"float NavAreaTravelDistance(TFNavArea startArea, CTFNavArea endArea, float flMaxPathLength)": {
		"prefix": "NavAreaTravelDistance",
		"body": [
			"NavAreaTravelDistance(${1:TFNavArea startArea}, ${2:CTFNavArea endArea}, ${3:float flMaxPathLength})$0"
		],
		"description": "compute distance between two areas. Return -1 if can't reach 'endArea' from 'startArea'"
	},
	"handle Next(handle previous)": {
		"prefix": "Next",
		"body": [
			"Next(${1:handle previous})$0"
		],
		"description": "At the given reference of a previously-found entity, returns the next one after it in the list."
	},
	"handle NextMovePeer()": {
		"prefix": "NextMovePeer",
		"body": [
			"NextMovePeer()$0"
		],
		"description": ""
	},
	"Quaternion Norm()": {
		"prefix": "Norm",
		"body": [
			"Norm()$0"
		],
		"description": "Normalizes the 4D vector length."
	},
	"void OnLandOnGround(handle)": {
		"prefix": "OnLandOnGround",
		"body": [
			"OnLandOnGround(${1:handle})$0"
		],
		"description": "Manually run the OnLandOnGround callback. Typically invoked when bot lands on the ground after being in the air"
	},
	"void OnLeaveGround(handle)": {
		"prefix": "OnLeaveGround",
		"body": [
			"OnLeaveGround(${1:handle})$0"
		],
		"description": "Manually run the OnLeaveGround callback. Typically invoked when bot leaves ground for any reason"
	},
	"PI": {
		"prefix": "PI",
		"body": [
			""
		],
		"description": ""
	},
	"void PickupObject(handle player, handle entity)": {
		"prefix": "PickupObject",
		"body": [
			"PickupObject(${1:handle player}, ${2:handle entity})$0"
		],
		"description": "Object from world is put into the \"Held\" slot of the player. Warning: it will smoothly interpolate from where it is to the players hand - which is a bit goofy if it is on other side of level."
	},
	"Pitch()": {
		"prefix": "Pitch",
		"body": [
			"Pitch()$0"
		],
		"description": ""
	},
	"float PlayScene(string, float)": {
		"prefix": "PlayScene",
		"body": [
			"PlayScene(${1:string}, ${2:float})$0"
		],
		"description": "Play the specified .vcd file."
	},
	"CBasePlayer PlayerInstanceFromIndex(int index)": {
		"prefix": "PlayerInstanceFromIndex",
		"body": [
			"PlayerInstanceFromIndex(${1:int index})$0"
		],
		"description": "Get a script handle of a player using the player index."
	},
	"bool PlayerReadyStatus_ArePlayersOnTeamReady(int)": {
		"prefix": "PlayerReadyStatus_ArePlayersOnTeamReady",
		"body": [
			"PlayerReadyStatus_ArePlayersOnTeamReady(${1:int})$0"
		],
		"description": ""
	},
	"bool PlayerReadyStatus_HaveMinPlayersToEnable()": {
		"prefix": "PlayerReadyStatus_HaveMinPlayersToEnable",
		"body": [
			"PlayerReadyStatus_HaveMinPlayersToEnable()$0"
		],
		"description": ""
	},
	"void PlayerReadyStatus_ResetState()": {
		"prefix": "PlayerReadyStatus_ResetState",
		"body": [
			"PlayerReadyStatus_ResetState()$0"
		],
		"description": ""
	},
	"bool PlayersAreOnMatchSummaryStage()": {
		"prefix": "PlayersAreOnMatchSummaryStage",
		"body": [
			"PlayersAreOnMatchSummaryStage()$0"
		],
		"description": ""
	},
	"bool PointsMayBeCaptured()": {
		"prefix": "PointsMayBeCaptured",
		"body": [
			"PointsMayBeCaptured()$0"
		],
		"description": "Are points able to be captured?"
	},
	"PostScriptExecute()": {
		"prefix": "PostScriptExecute",
		"body": [
			"PostScriptExecute()$0"
		],
		"description": ""
	},
	"bool PrecacheEntityFromTable(table keyvalues)": {
		"prefix": "PrecacheEntityFromTable",
		"body": [
			"PrecacheEntityFromTable(${1:table keyvalues})$0"
		],
		"description": "Precache an entity from KeyValues in a table; useful for entenv_shake."
	},
	"int PrecacheModel(string filename)": {
		"prefix": "PrecacheModel",
		"body": [
			"PrecacheModel(${1:string filename})$0"
		],
		"description": "Precache a model and return index of the model."
	},
	"void PrecacheScriptSound(string)": {
		"prefix": "PrecacheScriptSound",
		"body": [
			"PrecacheScriptSound(${1:string})$0"
		],
		"description": ""
	},
	"void PrecacheSound(string soundName)": {
		"prefix": "PrecacheSound",
		"body": [
			"PrecacheSound(${1:string soundName})$0"
		],
		"description": "Precache a sound."
	},
	"void PrecacheSoundScript(string)": {
		"prefix": "PrecacheSoundScript",
		"body": [
			"PrecacheSoundScript(${1:string})$0"
		],
		"description": "Precache a sound for later playing."
	},
	"void PressAltFireButton(float)": {
		"prefix": "PressAltFireButton",
		"body": [
			"PressAltFireButton(${1:float})$0"
		],
		"description": ""
	},
	"void PressFireButton(float)": {
		"prefix": "PressFireButton",
		"body": [
			"PressFireButton(${1:float})$0"
		],
		"description": ""
	},
	"void PressSpecialFireButton(float)": {
		"prefix": "PressSpecialFireButton",
		"body": [
			"PressSpecialFireButton(${1:float})$0"
		],
		"description": ""
	},
	"void PrimaryAttack()": {
		"prefix": "PrimaryAttack",
		"body": [
			"PrimaryAttack()$0"
		],
		"description": "Force a primary attack"
	},
	"PrintHelp()": {
		"prefix": "PrintHelp",
		"body": [
			"PrintHelp()$0"
		],
		"description": ""
	},
	"Quaternion(float x, float y, float z, float w)": {
		"prefix": "Quaternion",
		"body": [
			"Quaternion(${1:float x}, ${2:float y}, ${3:float z}, ${4:float w})$0"
		],
		"description": "Creates a new quaternion of the form w + x i + y j + z k."
	},
	"RAND_MAX": {
		"prefix": "RAND_MAX",
		"body": [
			""
		],
		"description": ""
	},
	"float RandomFloat(float min, float max)": {
		"prefix": "RandomFloat",
		"body": [
			"RandomFloat(${1:float min}, ${2:float max})$0"
		],
		"description": "Generate a random floating-point number within a range, inclusive."
	},
	"int RandomInt(int min, int max)": {
		"prefix": "RandomInt",
		"body": [
			"RandomInt(${1:int min}, ${2:int max})$0"
		],
		"description": "Generate a random integer within a range, inclusive."
	},
	"void Regenerate(bool)": {
		"prefix": "Regenerate",
		"body": [
			"Regenerate(${1:bool})$0"
		],
		"description": "Resupplies a player. If regen health/ammo is set, clears negative conds, gives back player health/ammo"
	},
	"void RegisterAvoidanceObstacle(handle entity)": {
		"prefix": "RegisterAvoidanceObstacle",
		"body": [
			"RegisterAvoidanceObstacle(${1:handle entity})$0"
		],
		"description": "registers avoidance obstacle"
	},
	"void RegisterFunctionDocumentation(unknown func, string name, string signature, string description)": {
		"prefix": "RegisterFunctionDocumentation",
		"body": [
			"RegisterFunctionDocumentation(${1:unknown func}, ${2:string name}, ${3:string signature}, ${4:string description})$0"
		],
		"description": ""
	},
	"void RegisterScriptGameEventListener(string eventName)": {
		"prefix": "RegisterScriptGameEventListener",
		"body": [
			"RegisterScriptGameEventListener(${1:string eventName})$0"
		],
		"description": "Register as a listener for a game event from script. It's what __CollectGameEventCallbacks() uses to register event callbacks to the C++ code."
	},
	"void RegisterScriptHookListener(string)": {
		"prefix": "RegisterScriptHookListener",
		"body": [
			"RegisterScriptHookListener(${1:string})$0"
		],
		"description": "Register as a listener for a script hook from script."
	},
	"void ReleaseKeyValues()": {
		"prefix": "ReleaseKeyValues",
		"body": [
			"ReleaseKeyValues()$0"
		],
		"description": "Releases the contents of the instance."
	},
	"void RemoveAllItems(bool)": {
		"prefix": "RemoveAllItems",
		"body": [
			"RemoveAllItems(${1:bool})$0"
		],
		"description": ""
	},
	"void RemoveAllObjects(bool)": {
		"prefix": "RemoveAllObjects",
		"body": [
			"RemoveAllObjects(${1:bool})$0"
		],
		"description": "Remove all player objects. Eg. dispensers/sentries."
	},
	"void RemoveAttribute(string)": {
		"prefix": "RemoveAttribute",
		"body": [
			"RemoveAttribute(${1:string})$0"
		],
		"description": "Remove an attribute to the entity"
	},
	"void RemoveAttributes(int)": {
		"prefix": "RemoveAttributes",
		"body": [
			"RemoveAttributes(${1:int})$0"
		],
		"description": "Removes area attribute bits"
	},
	"void RemoveBotAttribute(int)": {
		"prefix": "RemoveBotAttribute",
		"body": [
			"RemoveBotAttribute(${1:int})$0"
		],
		"description": "Removes attribute flags on this TFBot"
	},
	"void RemoveBotTag(string)": {
		"prefix": "RemoveBotTag",
		"body": [
			"RemoveBotTag(${1:string})$0"
		],
		"description": "Removes a bot tag"
	},
	"void RemoveBroadcastTeamTarget(int)": {
		"prefix": "RemoveBroadcastTeamTarget",
		"body": [
			"RemoveBroadcastTeamTarget(${1:int})$0"
		],
		"description": "Removes a team (by index) from the broadcast list"
	},
	"void RemoveCond(ETFCond cond)": {
		"prefix": "RemoveCond",
		"body": [
			"RemoveCond(${1:ETFCond cond})$0"
		],
		"description": ""
	},
	"void RemoveCondEx(ETFCond cond, bool ignoreDuration)": {
		"prefix": "RemoveCondEx",
		"body": [
			"RemoveCondEx(${1:ETFCond cond}, ${2:bool ignoreDuration})$0"
		],
		"description": ""
	},
	"void RemoveCurrency(int)": {
		"prefix": "RemoveCurrency",
		"body": [
			"RemoveCurrency(${1:int})$0"
		],
		"description": "Take away money from a player for reasons such as ie. spending."
	},
	"void RemoveCustomAttribute(string)": {
		"prefix": "RemoveCustomAttribute",
		"body": [
			"RemoveCustomAttribute(${1:string})$0"
		],
		"description": "Remove a custom attribute to the player"
	},
	"RemoveDelegation()": {
		"prefix": "RemoveDelegation",
		"body": [
			"RemoveDelegation()$0"
		],
		"description": ""
	},
	"void RemoveDisguise()": {
		"prefix": "RemoveDisguise",
		"body": [
			"RemoveDisguise()$0"
		],
		"description": "Undisguise a spy."
	},
	"void RemoveEFlags(int)": {
		"prefix": "RemoveEFlags",
		"body": [
			"RemoveEFlags(${1:int})$0"
		],
		"description": ""
	},
	"void RemoveFlag(int)": {
		"prefix": "RemoveFlag",
		"body": [
			"RemoveFlag(${1:int})$0"
		],
		"description": ""
	},
	"void RemoveInvisibility()": {
		"prefix": "RemoveInvisibility",
		"body": [
			"RemoveInvisibility()$0"
		],
		"description": "Un-invisible a spy."
	},
	"void RemoveOrthogonalConnections(int dir)": {
		"prefix": "RemoveOrthogonalConnections",
		"body": [
			"RemoveOrthogonalConnections(${1:int dir})$0"
		],
		"description": "Removes all connections in directions to left and right of specified direction"
	},
	"void RemoveOutput(handle entity, string outputName, string targetName, string inputName, string parameter)": {
		"prefix": "RemoveOutput",
		"body": [
			"RemoveOutput(${1:handle entity}, ${2:string outputName}, ${3:string targetName}, ${4:string inputName}, ${5:string parameter})$0"
		],
		"description": "Removes an output from the entity."
	},
	"void RemoveSolidFlags(int)": {
		"prefix": "RemoveSolidFlags",
		"body": [
			"RemoveSolidFlags(${1:int})$0"
		],
		"description": ""
	},
	"void RemoveTeleportEffect()": {
		"prefix": "RemoveTeleportEffect",
		"body": [
			"RemoveTeleportEffect()$0"
		],
		"description": ""
	},
	"void RemoveWeaponRestriction(int)": {
		"prefix": "RemoveWeaponRestriction",
		"body": [
			"RemoveWeaponRestriction(${1:int})$0"
		],
		"description": "Removes weapon restriction flags"
	},
	"void Reset()": {
		"prefix": "Reset",
		"body": [
			"Reset()$0"
		],
		"description": "Resets the internal update state"
	},
	"void ResetScores()": {
		"prefix": "ResetScores",
		"body": [
			"ResetScores()$0"
		],
		"description": ""
	},
	"void ResetSequence(int)": {
		"prefix": "ResetSequence",
		"body": [
			"ResetSequence(${1:int})$0"
		],
		"description": "Reset a sequence by id. If the id is different than the current sequence, switch to the new sequence"
	},
	"Resolve()": {
		"prefix": "Resolve",
		"body": [
			"Resolve()$0"
		],
		"description": ""
	},
	"RetrieveNativeSignature()": {
		"prefix": "RetrieveNativeSignature",
		"body": [
			"RetrieveNativeSignature()$0"
		],
		"description": ""
	},
	"Roll()": {
		"prefix": "Roll",
		"body": [
			"Roll()$0"
		],
		"description": ""
	},
	"void RollRareSpell()": {
		"prefix": "RollRareSpell",
		"body": [
			"RollRareSpell()$0"
		],
		"description": ""
	},
	"QAngle RotateOrientation(QAngle, QAngle)": {
		"prefix": "RotateOrientation",
		"body": [
			"RotateOrientation(${1:QAngle}, ${2:QAngle})$0"
		],
		"description": "Rotate a QAngle by another QAngle."
	},
	"Vector RotatePosition(Vector origin, QAngle rotation, Vector input)": {
		"prefix": "RotatePosition",
		"body": [
			"RotatePosition(${1:Vector origin}, ${2:QAngle rotation}, ${3:Vector input})$0"
		],
		"description": "Rotate the input Vector around an origin."
	},
	"void Run()": {
		"prefix": "Run",
		"body": [
			"Run()$0"
		],
		"description": "Set desired movement speed to running"
	},
	"void Say(CBasePlayer player, string message, bool teamOnly)": {
		"prefix": "Say",
		"body": [
			"Say(${1:CBasePlayer player}, ${2:string message}, ${3:bool teamOnly})$0"
		],
		"description": "Calling this will have the specified player send the message to chat, either to teamOnly (true) or to everyone."
	},
	"Vector Scale(float factor)": {
		"prefix": "Scale",
		"body": [
			"Scale(${1:float factor})$0"
		],
		"description": "Scales the vector magnitude."
	},
	"void ScreenFade(handle player, int red, int green, int blue, int alpha, float fadeTime, float fadeHold, int flags)": {
		"prefix": "ScreenFade",
		"body": [
			"ScreenFade(${1:handle player}, ${2:int red}, ${3:int green}, ${4:int blue}, ${5:int alpha}, ${6:float fadeTime}, ${7:float fadeHold}, ${8:int flags})$0"
		],
		"description": "Start a customisable screenfade."
	},
	"void ScreenShake(Vector vecCenter, float flAmplitude, float flFrequency, float flDuration, float flRadius, int eCommand, bool bAirShake)": {
		"prefix": "ScreenShake",
		"body": [
			"ScreenShake(${1:Vector vecCenter}, ${2:float flAmplitude}, ${3:float flFrequency}, ${4:float flDuration}, ${5:float flRadius}, ${6:int eCommand}, ${7:bool bAirShake})$0"
		],
		"description": "Start a customisable screenshake; eCommand( SHAKE_START = 0, SHAKE_STOP = 1 )."
	},
	"void ScriptDebugAddTextFilter()": {
		"prefix": "ScriptDebugAddTextFilter",
		"body": [
			"ScriptDebugAddTextFilter()$0"
		],
		"description": ""
	},
	"void ScriptDebugAddTrace()": {
		"prefix": "ScriptDebugAddTrace",
		"body": [
			"ScriptDebugAddTrace()$0"
		],
		"description": ""
	},
	"void ScriptDebugAddWatch()": {
		"prefix": "ScriptDebugAddWatch",
		"body": [
			"ScriptDebugAddWatch()$0"
		],
		"description": ""
	},
	"void ScriptDebugAddWatchPattern()": {
		"prefix": "ScriptDebugAddWatchPattern",
		"body": [
			"ScriptDebugAddWatchPattern()$0"
		],
		"description": ""
	},
	"void ScriptDebugAddWatches()": {
		"prefix": "ScriptDebugAddWatches",
		"body": [
			"ScriptDebugAddWatches()$0"
		],
		"description": ""
	},
	"void ScriptDebugClearTraces()": {
		"prefix": "ScriptDebugClearTraces",
		"body": [
			"ScriptDebugClearTraces()$0"
		],
		"description": ""
	},
	"void ScriptDebugClearWatches()": {
		"prefix": "ScriptDebugClearWatches",
		"body": [
			"ScriptDebugClearWatches()$0"
		],
		"description": ""
	},
	"void ScriptDebugDefaultWatchColor()": {
		"prefix": "ScriptDebugDefaultWatchColor",
		"body": [
			"ScriptDebugDefaultWatchColor()$0"
		],
		"description": ""
	},
	"void ScriptDebugDraw()": {
		"prefix": "ScriptDebugDraw",
		"body": [
			"ScriptDebugDraw()$0"
		],
		"description": ""
	},
	"ScriptDebugDrawTextEnabled": {
		"prefix": "ScriptDebugDrawTextEnabled",
		"body": [
			""
		],
		"description": ""
	},
	"void ScriptDebugDrawWatches()": {
		"prefix": "ScriptDebugDrawWatches",
		"body": [
			"ScriptDebugDrawWatches()$0"
		],
		"description": ""
	},
	"ScriptDebugDrawWatchesEnabled": {
		"prefix": "ScriptDebugDrawWatchesEnabled",
		"body": [
			""
		],
		"description": ""
	},
	"void ScriptDebugDumpKeys()": {
		"prefix": "ScriptDebugDumpKeys",
		"body": [
			"ScriptDebugDumpKeys()$0"
		],
		"description": ""
	},
	"void ScriptDebugHook()": {
		"prefix": "ScriptDebugHook",
		"body": [
			"ScriptDebugHook()$0"
		],
		"description": ""
	},
	"ScriptDebugInDebugDraw": {
		"prefix": "ScriptDebugInDebugDraw",
		"body": [
			""
		],
		"description": ""
	},
	"void ScriptDebugIterateKeys()": {
		"prefix": "ScriptDebugIterateKeys",
		"body": [
			"ScriptDebugIterateKeys()$0"
		],
		"description": ""
	},
	"void ScriptDebugIterateKeysRecursive()": {
		"prefix": "ScriptDebugIterateKeysRecursive",
		"body": [
			"ScriptDebugIterateKeysRecursive()$0"
		],
		"description": ""
	},
	"void ScriptDebugRemoveTextFilter()": {
		"prefix": "ScriptDebugRemoveTextFilter",
		"body": [
			"ScriptDebugRemoveTextFilter()$0"
		],
		"description": ""
	},
	"void ScriptDebugRemoveTrace()": {
		"prefix": "ScriptDebugRemoveTrace",
		"body": [
			"ScriptDebugRemoveTrace()$0"
		],
		"description": ""
	},
	"void ScriptDebugRemoveWatch()": {
		"prefix": "ScriptDebugRemoveWatch",
		"body": [
			"ScriptDebugRemoveWatch()$0"
		],
		"description": ""
	},
	"void ScriptDebugRemoveWatchPattern()": {
		"prefix": "ScriptDebugRemoveWatchPattern",
		"body": [
			"ScriptDebugRemoveWatchPattern()$0"
		],
		"description": ""
	},
	"void ScriptDebugRemoveWatches()": {
		"prefix": "ScriptDebugRemoveWatches",
		"body": [
			"ScriptDebugRemoveWatches()$0"
		],
		"description": ""
	},
	"void ScriptDebugText()": {
		"prefix": "ScriptDebugText",
		"body": [
			"ScriptDebugText()$0"
		],
		"description": ""
	},
	"void ScriptDebugTextDraw()": {
		"prefix": "ScriptDebugTextDraw",
		"body": [
			"ScriptDebugTextDraw()$0"
		],
		"description": ""
	},
	"ScriptDebugTextFilters": {
		"prefix": "ScriptDebugTextFilters",
		"body": [
			""
		],
		"description": ""
	},
	"ScriptDebugTextIndent": {
		"prefix": "ScriptDebugTextIndent",
		"body": [
			""
		],
		"description": ""
	},
	"void ScriptDebugTextPrint()": {
		"prefix": "ScriptDebugTextPrint",
		"body": [
			"ScriptDebugTextPrint()$0"
		],
		"description": ""
	},
	"void ScriptDebugTextTrace()": {
		"prefix": "ScriptDebugTextTrace",
		"body": [
			"ScriptDebugTextTrace()$0"
		],
		"description": ""
	},
	"void ScriptDebugTraceAll()": {
		"prefix": "ScriptDebugTraceAll",
		"body": [
			"ScriptDebugTraceAll()$0"
		],
		"description": ""
	},
	"ScriptDebugTraceAllOn": {
		"prefix": "ScriptDebugTraceAllOn",
		"body": [
			""
		],
		"description": ""
	},
	"ScriptDebugTraces": {
		"prefix": "ScriptDebugTraces",
		"body": [
			""
		],
		"description": ""
	},
	"void ScriptDebugWatches()": {
		"prefix": "ScriptDebugWatches",
		"body": [
			"ScriptDebugWatches()$0"
		],
		"description": ""
	},
	"bool ScriptHooksEnabled()": {
		"prefix": "ScriptHooksEnabled",
		"body": [
			"ScriptHooksEnabled()$0"
		],
		"description": "Returns whether script hooks are currently enabled."
	},
	"void SecondaryAttack()": {
		"prefix": "SecondaryAttack",
		"body": [
			"SecondaryAttack()$0"
		],
		"description": "Force a secondary attack"
	},
	"bool SendGlobalGameEvent(string, handle)": {
		"prefix": "SendGlobalGameEvent",
		"body": [
			"SendGlobalGameEvent(${1:string}, ${2:handle})$0"
		],
		"description": "Sends a real game event to everything. Parameters are passed in a squirrel table."
	},
	"void SendToConsole(string command)": {
		"prefix": "SendToConsole",
		"body": [
			"SendToConsole(${1:string command})$0"
		],
		"description": "Send a string to the console as a command. Note: this obeys the behavior of the sv_allow_point_servercommand convar. By default, this command will do nothing unless the server has this command to set to \"always\""
	},
	"void SendToConsoleServer(string command)": {
		"prefix": "SendToConsoleServer",
		"body": [
			"SendToConsoleServer(${1:string command})$0"
		],
		"description": "Copy of SendToServerConsole with another name for compat."
	},
	"void SendToServerConsole(string command)": {
		"prefix": "SendToServerConsole",
		"body": [
			"SendToServerConsole(${1:string command})$0"
		],
		"description": "Send a string that gets executed on the server as a ServerCommand."
	},
	"void SetAbsAngles(QAngle)": {
		"prefix": "SetAbsAngles",
		"body": [
			"SetAbsAngles(${1:QAngle})$0"
		],
		"description": "Set entity pitch, yaw, roll as QAngles"
	},
	"void SetAbsOrigin(Vector)": {
		"prefix": "SetAbsOrigin",
		"body": [
			"SetAbsOrigin(${1:Vector})$0"
		],
		"description": "SetAbsOrigin"
	},
	"void SetAbsVelocity(Vector)": {
		"prefix": "SetAbsVelocity",
		"body": [
			"SetAbsVelocity(${1:Vector})$0"
		],
		"description": "Sets the current absolute velocity of the entity"
	},
	"void SetAngles(float, float, float)": {
		"prefix": "SetAngles",
		"body": [
			"SetAngles(${1:float}, ${2:float}, ${3:float})$0"
		],
		"description": "Set entity pitch, yaw, roll."
	},
	"void SetAngularVelocity(float, float, float)": {
		"prefix": "SetAngularVelocity",
		"body": [
			"SetAngularVelocity(${1:float}, ${2:float}, ${3:float})$0"
		],
		"description": "Set the local angular velocity - takes float pitch,yaw,roll velocities"
	},
	"void SetAttentionFocus(handle)": {
		"prefix": "SetAttentionFocus",
		"body": [
			"SetAttentionFocus(${1:handle})$0"
		],
		"description": "Sets our current attention focus to this entity"
	},
	"void SetAttributeTF(int)": {
		"prefix": "SetAttributeTF",
		"body": [
			"SetAttributeTF(${1:int})$0"
		],
		"description": "Set TF-specific area attributes"
	},
	"void SetAttributes(int)": {
		"prefix": "SetAttributes",
		"body": [
			"SetAttributes(${1:int})$0"
		],
		"description": "Set area attribute bits"
	},
	"void SetAutoJump(float, float)": {
		"prefix": "SetAutoJump",
		"body": [
			"SetAutoJump(${1:float}, ${2:float})$0"
		],
		"description": "Sets if the bot should automatically jump"
	},
	"void SetBodygroup(int, int)": {
		"prefix": "SetBodygroup",
		"body": [
			"SetBodygroup(${1:int}, ${2:int})$0"
		],
		"description": "Sets a bodygroup"
	},
	"void SetClip1(int)": {
		"prefix": "SetClip1",
		"body": [
			"SetClip1(${1:int})$0"
		],
		"description": "Set current ammo in clip1"
	},
	"void SetClip2(int)": {
		"prefix": "SetClip2",
		"body": [
			"SetClip2(${1:int})$0"
		],
		"description": "Set current ammo in clip2"
	},
	"void SetCollisionGroup(int)": {
		"prefix": "SetCollisionGroup",
		"body": [
			"SetCollisionGroup(${1:int})$0"
		],
		"description": ""
	},
	"void SetCondDuration(ETFCond cond, float duration)": {
		"prefix": "SetCondDuration",
		"body": [
			"SetCondDuration(${1:ETFCond cond}, ${2:float duration})$0"
		],
		"description": ""
	},
	"void SetCurrency(int)": {
		"prefix": "SetCurrency",
		"body": [
			"SetCurrency(${1:int})$0"
		],
		"description": "Set player's cash for game modes with upgrades, ie. MvM"
	},
	"void SetCurrentTauntMoveSpeed(float)": {
		"prefix": "SetCurrentTauntMoveSpeed",
		"body": [
			"SetCurrentTauntMoveSpeed(${1:float})$0"
		],
		"description": ""
	},
	"void SetCustomModel(string)": {
		"prefix": "SetCustomModel",
		"body": [
			"SetCustomModel(${1:string})$0"
		],
		"description": ""
	},
	"void SetCustomModelOffset(Vector)": {
		"prefix": "SetCustomModelOffset",
		"body": [
			"SetCustomModelOffset(${1:Vector})$0"
		],
		"description": ""
	},
	"void SetCustomModelRotates(bool)": {
		"prefix": "SetCustomModelRotates",
		"body": [
			"SetCustomModelRotates(${1:bool})$0"
		],
		"description": ""
	},
	"void SetCustomModelRotation(QAngle)": {
		"prefix": "SetCustomModelRotation",
		"body": [
			"SetCustomModelRotation(${1:QAngle})$0"
		],
		"description": ""
	},
	"void SetCustomModelVisibleToSelf(bool)": {
		"prefix": "SetCustomModelVisibleToSelf",
		"body": [
			"SetCustomModelVisibleToSelf(${1:bool})$0"
		],
		"description": ""
	},
	"void SetCustomModelWithClassAnimations(string)": {
		"prefix": "SetCustomModelWithClassAnimations",
		"body": [
			"SetCustomModelWithClassAnimations(${1:string})$0"
		],
		"description": ""
	},
	"void SetCustomViewModel(string)": {
		"prefix": "SetCustomViewModel",
		"body": [
			"SetCustomViewModel(${1:string})$0"
		],
		"description": "Sets a custom view model for this weapon by model name"
	},
	"void SetCustomViewModelModelIndex(int)": {
		"prefix": "SetCustomViewModelModelIndex",
		"body": [
			"SetCustomViewModelModelIndex(${1:int})$0"
		],
		"description": "Sets a custom view model for this weapon by modelindex"
	},
	"void SetCycle(float)": {
		"prefix": "SetCycle",
		"body": [
			"SetCycle(${1:float})$0"
		],
		"description": "Sets the models current cycle"
	},
	"void SetDesiredSpeed(float)": {
		"prefix": "SetDesiredSpeed",
		"body": [
			"SetDesiredSpeed(${1:float})$0"
		],
		"description": "Set desired speed for locomotor movement"
	},
	"void SetDifficulty(int)": {
		"prefix": "SetDifficulty",
		"body": [
			"SetDifficulty(${1:int})$0"
		],
		"description": "Sets the bots difficulty level"
	},
	"void SetDisguiseAmmoCount(int)": {
		"prefix": "SetDisguiseAmmoCount",
		"body": [
			"SetDisguiseAmmoCount(${1:int})$0"
		],
		"description": ""
	},
	"void SetDrawEnabled(bool)": {
		"prefix": "SetDrawEnabled",
		"body": [
			"SetDrawEnabled(${1:bool})$0"
		],
		"description": "Enables drawing if you pass true, disables drawing if you pass false."
	},
	"void SetEFlags(int)": {
		"prefix": "SetEFlags",
		"body": [
			"SetEFlags(${1:int})$0"
		],
		"description": ""
	},
	"void SetFakeClientConVarValue(handle bot, string cvar, string value)": {
		"prefix": "SetFakeClientConVarValue",
		"body": [
			"SetFakeClientConVarValue(${1:handle bot}, ${2:string cvar}, ${3:string value})$0"
		],
		"description": "Sets a USERINFO client ConVar for a fakeclient."
	},
	"void SetForceLocalDraw(bool)": {
		"prefix": "SetForceLocalDraw",
		"body": [
			"SetForceLocalDraw(${1:bool})$0"
		],
		"description": "Forces the player to be drawn as if they are third person"
	},
	"void SetForcedTauntCam(int)": {
		"prefix": "SetForcedTauntCam",
		"body": [
			"SetForcedTauntCam(${1:int})$0"
		],
		"description": ""
	},
	"void SetForwardVector(Vector)": {
		"prefix": "SetForwardVector",
		"body": [
			"SetForwardVector(${1:Vector})$0"
		],
		"description": "Set the orientation of the entity to have this forward vector"
	},
	"void SetFriction(float)": {
		"prefix": "SetFriction",
		"body": [
			"SetFriction(${1:float})$0"
		],
		"description": ""
	},
	"void SetGrapplingHookTarget(handle, bool)": {
		"prefix": "SetGrapplingHookTarget",
		"body": [
			"SetGrapplingHookTarget(${1:handle}, ${2:bool})$0"
		],
		"description": "Set the player's target grapple entity"
	},
	"void SetGravity(float)": {
		"prefix": "SetGravity",
		"body": [
			"SetGravity(${1:float})$0"
		],
		"description": ""
	},
	"void SetGravityMultiplier(float multiplier)": {
		"prefix": "SetGravityMultiplier",
		"body": [
			"SetGravityMultiplier(${1:float multiplier})$0"
		],
		"description": ""
	},
	"void SetGroupSpawnTables(handle, handle)": {
		"prefix": "SetGroupSpawnTables",
		"body": [
			"SetGroupSpawnTables(${1:handle}, ${2:handle})$0"
		],
		"description": "Cache the group spawn tables"
	},
	"void SetHealth(int)": {
		"prefix": "SetHealth",
		"body": [
			"SetHealth(${1:int})$0"
		],
		"description": ""
	},
	"void SetHomeArea(handle)": {
		"prefix": "SetHomeArea",
		"body": [
			"SetHomeArea(${1:handle})$0"
		],
		"description": "Returns the home nav area of the bot -- may be nil."
	},
	"void SetIsMiniBoss(bool)": {
		"prefix": "SetIsMiniBoss",
		"body": [
			"SetIsMiniBoss(${1:bool})$0"
		],
		"description": "Make this player an MvM mini-boss."
	},
	"void SetLocalAngles(QAngle)": {
		"prefix": "SetLocalAngles",
		"body": [
			"SetLocalAngles(${1:QAngle})$0"
		],
		"description": ""
	},
	"void SetLocalOrigin(Vector)": {
		"prefix": "SetLocalOrigin",
		"body": [
			"SetLocalOrigin(${1:Vector})$0"
		],
		"description": ""
	},
	"void SetMannVsMachineAlarmStatus(bool status)": {
		"prefix": "SetMannVsMachineAlarmStatus",
		"body": [
			"SetMannVsMachineAlarmStatus(${1:bool status})$0"
		],
		"description": ""
	},
	"void SetMaxHealth(int)": {
		"prefix": "SetMaxHealth",
		"body": [
			"SetMaxHealth(${1:int})$0"
		],
		"description": ""
	},
	"void SetMaxVisionRangeOverride(float)": {
		"prefix": "SetMaxVisionRangeOverride",
		"body": [
			"SetMaxVisionRangeOverride(${1:float})$0"
		],
		"description": "Sets max vision range override for the bot"
	},
	"void SetModel(string)": {
		"prefix": "SetModel",
		"body": [
			"SetModel(${1:string})$0"
		],
		"description": "Set a model for this entity"
	},
	"void SetModelScale(float, float)": {
		"prefix": "SetModelScale",
		"body": [
			"SetModelScale(${1:float}, ${2:float})$0"
		],
		"description": "(scale, change_duration) Changes a model's scale over time"
	},
	"void SetModelSimple(string)": {
		"prefix": "SetModelSimple",
		"body": [
			"SetModelSimple(${1:string})$0"
		],
		"description": "Set a model for this entity. Matches easier behaviour of the SetModel input, automatically precaches, maintains sequence/cycle if possible."
	},
	"void SetMoveType(EMoveType movetype, EMoveCollide movecollide)": {
		"prefix": "SetMoveType",
		"body": [
			"SetMoveType(${1:EMoveType movetype}, ${2:EMoveCollide movecollide})$0"
		],
		"description": ""
	},
	"void SetNextChangeClassTime(float)": {
		"prefix": "SetNextChangeClassTime",
		"body": [
			"SetNextChangeClassTime(${1:float})$0"
		],
		"description": "Set next change class time."
	},
	"void SetNextChangeTeamTime(float)": {
		"prefix": "SetNextChangeTeamTime",
		"body": [
			"SetNextChangeTeamTime(${1:float})$0"
		],
		"description": "Set next change team time."
	},
	"void SetNextRegenTime(float)": {
		"prefix": "SetNextRegenTime",
		"body": [
			"SetNextRegenTime(${1:float})$0"
		],
		"description": "Set next health regen time."
	},
	"void SetOrigin(Vector)": {
		"prefix": "SetOrigin",
		"body": [
			"SetOrigin(${1:Vector})$0"
		],
		"description": ""
	},
	"void SetOvertimeAllowedForCTF(bool state)": {
		"prefix": "SetOvertimeAllowedForCTF",
		"body": [
			"SetOvertimeAllowedForCTF(${1:bool state})$0"
		],
		"description": ""
	},
	"void SetOwner(handle)": {
		"prefix": "SetOwner",
		"body": [
			"SetOwner(${1:handle})$0"
		],
		"description": "Sets this entity's owner"
	},
	"void SetPhysAngularVelocity(Vector)": {
		"prefix": "SetPhysAngularVelocity",
		"body": [
			"SetPhysAngularVelocity(${1:Vector})$0"
		],
		"description": ""
	},
	"void SetPhysVelocity(Vector)": {
		"prefix": "SetPhysVelocity",
		"body": [
			"SetPhysVelocity(${1:Vector})$0"
		],
		"description": ""
	},
	"void SetPitchYawRoll(float pitch, float yaw, float roll)": {
		"prefix": "SetPitchYawRoll",
		"body": [
			"SetPitchYawRoll(${1:float pitch}, ${2:float yaw}, ${3:float roll})$0"
		],
		"description": "Recomputes the quaternion from the supplied Euler angles."
	},
	"void SetPlaceName(string name)": {
		"prefix": "SetPlaceName",
		"body": [
			"SetPlaceName(${1:string name})$0"
		],
		"description": "Set place name"
	},
	"void SetPlaybackRate(float)": {
		"prefix": "SetPlaybackRate",
		"body": [
			"SetPlaybackRate(${1:float})$0"
		],
		"description": "Set the current playback rate."
	},
	"void SetPlayerClass(int)": {
		"prefix": "SetPlayerClass",
		"body": [
			"SetPlayerClass(${1:int})$0"
		],
		"description": ""
	},
	"void SetPlayersInHell(bool state)": {
		"prefix": "SetPlayersInHell",
		"body": [
			"SetPlayersInHell(${1:bool state})$0"
		],
		"description": ""
	},
	"float SetPoseParameter(int, float)": {
		"prefix": "SetPoseParameter",
		"body": [
			"SetPoseParameter(${1:int}, ${2:float})$0"
		],
		"description": "(id, value) Sets a pose parameter value"
	},
	"void SetPropBool(handle entity, string propertyName, bool value)": {
		"prefix": "SetPropBool",
		"body": [
			"SetPropBool(${1:handle entity}, ${2:string propertyName}, ${3:bool value})$0"
		],
		"description": "Sets a netprop to the specified boolean."
	},
	"void SetPropBoolArray(handle entity, string propertyName, bool value, int arrayElement)": {
		"prefix": "SetPropBoolArray",
		"body": [
			"SetPropBoolArray(${1:handle entity}, ${2:string propertyName}, ${3:bool value}, ${4:int arrayElement})$0"
		],
		"description": "Sets a netprop from an array to the specified boolean."
	},
	"void SetPropEntity(handle entity, string propertyName, handle value)": {
		"prefix": "SetPropEntity",
		"body": [
			"SetPropEntity(${1:handle entity}, ${2:string propertyName}, ${3:handle value})$0"
		],
		"description": "Sets an EHANDLE-valued netprop (21 bit integer) to reference the specified entity."
	},
	"void SetPropEntityArray(handle entity, string propertyName, handle value, int arrayElement)": {
		"prefix": "SetPropEntityArray",
		"body": [
			"SetPropEntityArray(${1:handle entity}, ${2:string propertyName}, ${3:handle value}, ${4:int arrayElement})$0"
		],
		"description": "Sets an EHANDLE-valued netprop (21 bit integer) from an array to reference the specified entity."
	},
	"void SetPropFloat(handle entity, string propertyName, float value)": {
		"prefix": "SetPropFloat",
		"body": [
			"SetPropFloat(${1:handle entity}, ${2:string propertyName}, ${3:float value})$0"
		],
		"description": "Sets a netprop to the specified float."
	},
	"void SetPropFloatArray(handle entity, string propertyName, float value, int arrayElement)": {
		"prefix": "SetPropFloatArray",
		"body": [
			"SetPropFloatArray(${1:handle entity}, ${2:string propertyName}, ${3:float value}, ${4:int arrayElement})$0"
		],
		"description": "Sets a netprop from an array to the specified float."
	},
	"void SetPropInt(handle entity, string propertyName, int value)": {
		"prefix": "SetPropInt",
		"body": [
			"SetPropInt(${1:handle entity}, ${2:string propertyName}, ${3:int value})$0"
		],
		"description": "Sets a netprop to the specified integer."
	},
	"void SetPropInt(handle entity, string propertyName, int value, int arrayElement)": {
		"prefix": "SetPropInt",
		"body": [
			"SetPropInt(${1:handle entity}, ${2:string propertyName}, ${3:int value}, ${4:int arrayElement})$0"
		],
		"description": "Sets a netprop from an array to the specified integer."
	},
	"void SetPropString(handle entity, string propertyName, string value)": {
		"prefix": "SetPropString",
		"body": [
			"SetPropString(${1:handle entity}, ${2:string propertyName}, ${3:string value})$0"
		],
		"description": "Sets a netprop to the specified string."
	},
	"void SetPropStringArray(handle entity, string propertyName, string value, int arrayElement)": {
		"prefix": "SetPropStringArray",
		"body": [
			"SetPropStringArray(${1:handle entity}, ${2:string propertyName}, ${3:string value}, ${4:int arrayElement})$0"
		],
		"description": "Sets a netprop from an array to the specified string."
	},
	"void SetPropVector(handle entity, string propertyName, Vector value)": {
		"prefix": "SetPropVector",
		"body": [
			"SetPropVector(${1:handle entity}, ${2:string propertyName}, ${3:Vector value})$0"
		],
		"description": "Sets a netprop to the specified vector."
	},
	"void SetPropVectorArray(handle entity, string propertyName, Vector value, int arrayElement)": {
		"prefix": "SetPropVectorArray",
		"body": [
			"SetPropVectorArray(${1:handle entity}, ${2:string propertyName}, ${3:Vector value}, ${4:int arrayElement})$0"
		],
		"description": "Sets a netprop from an array to the specified vector."
	},
	"void SetRageMeter(float)": {
		"prefix": "SetRageMeter",
		"body": [
			"SetRageMeter(${1:float})$0"
		],
		"description": ""
	},
	"void SetScaleOverride(float)": {
		"prefix": "SetScaleOverride",
		"body": [
			"SetScaleOverride(${1:float})$0"
		],
		"description": "Sets the scale override for the bot"
	},
	"void SetScoutHypeMeter(float)": {
		"prefix": "SetScoutHypeMeter",
		"body": [
			"SetScoutHypeMeter(${1:float})$0"
		],
		"description": ""
	},
	"void SetScriptOverlayMaterial(string)": {
		"prefix": "SetScriptOverlayMaterial",
		"body": [
			"SetScriptOverlayMaterial(${1:string})$0"
		],
		"description": " Sets a view overlay material"
	},
	"void SetSequence(int)": {
		"prefix": "SetSequence",
		"body": [
			"SetSequence(${1:int})$0"
		],
		"description": "Set a sequence by id"
	},
	"void SetShouldQuickBuild(bool)": {
		"prefix": "SetShouldQuickBuild",
		"body": [
			"SetShouldQuickBuild(${1:bool})$0"
		],
		"description": "Sets if the bot should build instantly"
	},
	"void SetSize(Vector, Vector)": {
		"prefix": "SetSize",
		"body": [
			"SetSize(${1:Vector}, ${2:Vector})$0"
		],
		"description": ""
	},
	"void SetSkin(int)": {
		"prefix": "SetSkin",
		"body": [
			"SetSkin(${1:int})$0"
		],
		"description": "Sets the skin."
	},
	"void SetSkyboxTexture(string)": {
		"prefix": "SetSkyboxTexture",
		"body": [
			"SetSkyboxTexture(${1:string})$0"
		],
		"description": "Sets the current skybox texture"
	},
	"SetSolid(int)": {
		"prefix": "SetSolid",
		"body": [
			"SetSolid(${1:int})$0"
		],
		"description": ""
	},
	"SetSolidFlags(int)": {
		"prefix": "SetSolidFlags",
		"body": [
			"SetSolidFlags(${1:int})$0"
		],
		"description": ""
	},
	"void SetSpeedLimit(float)": {
		"prefix": "SetSpeedLimit",
		"body": [
			"SetSpeedLimit(${1:float})$0"
		],
		"description": "Set maximum speed bot can reach, regardless of desired speed"
	},
	"void SetSpyCloakMeter(float)": {
		"prefix": "SetSpyCloakMeter",
		"body": [
			"SetSpyCloakMeter(${1:float})$0"
		],
		"description": ""
	},
	"void SetSquadFormationError(float)": {
		"prefix": "SetSquadFormationError",
		"body": [
			"SetSquadFormationError(${1:float})$0"
		],
		"description": "Sets our formation error coefficient."
	},
	"void SetSubType(int)": {
		"prefix": "SetSubType",
		"body": [
			"SetSubType(${1:int})$0"
		],
		"description": "Set the weapon subtype"
	},
	"void SetTeam(int)": {
		"prefix": "SetTeam",
		"body": [
			"SetTeam(${1:int})$0"
		],
		"description": ""
	},
	"void SetUseBossHealthBar(bool)": {
		"prefix": "SetUseBossHealthBar",
		"body": [
			"SetUseBossHealthBar(${1:bool})$0"
		],
		"description": ""
	},
	"void SetUsingSpells(bool state)": {
		"prefix": "SetUsingSpells",
		"body": [
			"SetUsingSpells(${1:bool state})$0"
		],
		"description": ""
	},
	"void SetValue(string name, value)": {
		"prefix": "SetValue",
		"body": [
			"SetValue(${1:string name}, ${2:value})$0"
		],
		"description": "Sets the value of the convar. The convar must be in cfg/vscript_convar_allowlist.txt to be set. Convars marked as cheat-only can be set even if sv_cheats is off. Supported types are bool, int, float, string."
	},
	"void SetVelocity(Vector)": {
		"prefix": "SetVelocity",
		"body": [
			"SetVelocity(${1:Vector})$0"
		],
		"description": ""
	},
	"SetWaterLevel(int)": {
		"prefix": "SetWaterLevel",
		"body": [
			"SetWaterLevel(${1:int})$0"
		],
		"description": ""
	},
	"SetWaterType(int)": {
		"prefix": "SetWaterType",
		"body": [
			"SetWaterType(${1:int})$0"
		],
		"description": ""
	},
	"bool ShouldAutoJump()": {
		"prefix": "ShouldAutoJump",
		"body": [
			"ShouldAutoJump()$0"
		],
		"description": "Returns if the bot should automatically jump"
	},
	"bool ShouldQuickBuild()": {
		"prefix": "ShouldQuickBuild",
		"body": [
			"ShouldQuickBuild()$0"
		],
		"description": "Returns if the bot should build instantly"
	},
	"void ShowMessage(string message)": {
		"prefix": "ShowMessage",
		"body": [
			"ShowMessage(${1:string message})$0"
		],
		"description": "Print a hud message on all clients"
	},
	"void SnapEyeAngles(QAngle)": {
		"prefix": "SnapEyeAngles",
		"body": [
			"SnapEyeAngles(${1:QAngle})$0"
		],
		"description": "Snap the player's eye angles to this."
	},
	"void SpawnEntity()": {
		"prefix": "SpawnEntity",
		"body": [
			"SpawnEntity()$0"
		],
		"description": "Create an entity at the location of the maker"
	},
	"void SpawnEntityAtEntityOrigin(handle)": {
		"prefix": "SpawnEntityAtEntityOrigin",
		"body": [
			"SpawnEntityAtEntityOrigin(${1:handle})$0"
		],
		"description": "Create an entity at the location of a specified entity instance"
	},
	"void SpawnEntityAtLocation(Vector, Vector)": {
		"prefix": "SpawnEntityAtLocation",
		"body": [
			"SpawnEntityAtLocation(${1:Vector}, ${2:Vector})$0"
		],
		"description": "Create an entity at a specified location and orientaton, orientation is Euler angle in degrees (pitch, yaw, roll)"
	},
	"void SpawnEntityAtNamedEntityOrigin(string)": {
		"prefix": "SpawnEntityAtNamedEntityOrigin",
		"body": [
			"SpawnEntityAtNamedEntityOrigin(${1:string})$0"
		],
		"description": "Create an entity at the location of a named entity"
	},
	"handle SpawnEntityFromTable(string name, handle keyvalues)": {
		"prefix": "SpawnEntityFromTable",
		"body": [
			"SpawnEntityFromTable(${1:string name}, ${2:handle keyvalues})$0"
		],
		"description": "Spawn entity from KeyValues in table - 'name' is entity name, rest are KeyValues for spawn."
	},
	"bool SpawnEntityGroupFromTable(handle entityGroup)": {
		"prefix": "SpawnEntityGroupFromTable",
		"body": [
			"SpawnEntityGroupFromTable(${1:handle entityGroup})$0"
		],
		"description": "Hierarchically spawn an entity group from a set of spawn tables. See L4D2_EMS/Appendix:_Spawning."
	},
	"void Stop()": {
		"prefix": "Stop",
		"body": [
			"Stop()$0"
		],
		"description": "Set desired movement speed to stopped"
	},
	"void StopAmbientSoundOn(string soundName, handle entity)": {
		"prefix": "StopAmbientSoundOn",
		"body": [
			"StopAmbientSoundOn(${1:string soundName}, ${2:handle entity})$0"
		],
		"description": "Stop named sound on an entity using configurations similar to ambient_generic."
	},
	"void StopAnimation()": {
		"prefix": "StopAnimation",
		"body": [
			"StopAnimation()$0"
		],
		"description": "Stop the current animation (same as SetPlaybackRate 0.0)"
	},
	"void StopSound(string)": {
		"prefix": "StopSound",
		"body": [
			"StopSound(${1:string})$0"
		],
		"description": "Stops a sound on this entity."
	},
	"void StopSoundOn(string soundScript, handle entity)": {
		"prefix": "StopSoundOn",
		"body": [
			"StopSoundOn(${1:string soundScript}, ${2:handle entity})$0"
		],
		"description": "Stop named sound on an entity."
	},
	"void StringToFile(string file, string string)": {
		"prefix": "StringToFile",
		"body": [
			"StringToFile(${1:string file}, ${2:string string})$0"
		],
		"description": "Stores a string as a file."
	},
	"void StudioFrameAdvance()": {
		"prefix": "StudioFrameAdvance",
		"body": [
			"StudioFrameAdvance()$0"
		],
		"description": "Advance animation frame to some time in the future with an automatically calculated interval"
	},
	"void StudioFrameAdvanceManual(float)": {
		"prefix": "StudioFrameAdvanceManual",
		"body": [
			"StudioFrameAdvanceManual(${1:float})$0"
		],
		"description": "Advance animation frame to some time in the future with a manual interval"
	},
	"void TFMark()": {
		"prefix": "TFMark",
		"body": [
			"TFMark()$0"
		],
		"description": "Mark this nav area with the current marking scope."
	},
	"void TakeDamage(float flDamage, int nDamageType, handle hAttacker)": {
		"prefix": "TakeDamage",
		"body": [
			"TakeDamage(${1:float flDamage}, ${2:int nDamageType}, ${3:handle hAttacker})$0"
		],
		"description": ""
	},
	"void TakeDamageCustom(handle hInflictor, handle hAttacker, handle hWeapon, Vector vecDamageForce, Vector vecDamagePosition, float flDamage, int nDamageType, int nCustomDamageType)": {
		"prefix": "TakeDamageCustom",
		"body": [
			"TakeDamageCustom(${1:handle hInflictor}, ${2:handle hAttacker}, ${3:handle hWeapon}, ${4:Vector vecDamageForce}, ${5:Vector vecDamagePosition}, ${6:float flDamage}, ${7:int nDamageType}, ${8:int nCustomDamageType})$0"
		],
		"description": ""
	},
	"void TakeDamageEx(handle hInflictor, handle hAttacker, handle hWeapon, Vector vecDamageForce, Vector vecDamagePosition, float flDamage, int nDamageType)": {
		"prefix": "TakeDamageEx",
		"body": [
			"TakeDamageEx(${1:handle hInflictor}, ${2:handle hAttacker}, ${3:handle hWeapon}, ${4:Vector vecDamageForce}, ${5:Vector vecDamagePosition}, ${6:float flDamage}, ${7:int nDamageType})$0"
		],
		"description": ""
	},
	"void Teleport(bool, Vector, bool, QAngle, bool, Vector)": {
		"prefix": "Teleport",
		"body": [
			"Teleport(${1:bool}, ${2:Vector}, ${3:bool}, ${4:QAngle}, ${5:bool}, ${6:Vector})$0"
		],
		"description": "Teleports this entity"
	},
	"void TerminateScriptScope()": {
		"prefix": "TerminateScriptScope",
		"body": [
			"TerminateScriptScope()$0"
		],
		"description": "Clear the current script scope for this entity"
	},
	"float Time()": {
		"prefix": "Time",
		"body": [
			"Time()$0"
		],
		"description": "Get the current server time"
	},
	"string ToKVString()": {
		"prefix": "ToKVString",
		"body": [
			"ToKVString()$0"
		],
		"description": "Returns a string with the values separated by one space."
	},
	"QAngle ToQAngle()": {
		"prefix": "ToQAngle",
		"body": [
			"ToQAngle()$0"
		],
		"description": "Returns the angles resulting from the rotation."
	},
	"ToQuat()": {
		"prefix": "ToQuat",
		"body": [
			"ToQuat()$0"
		],
		"description": ""
	},
	"ToggleFlag(int)": {
		"prefix": "ToggleFlag",
		"body": [
			"ToggleFlag(${1:int})$0"
		],
		"description": ""
	},
	"bool TraceHull(table traceTable)": {
		"prefix": "TraceHull",
		"body": [
			"TraceHull(${1:table traceTable})$0"
		],
		"description": "Input Table: start, end, hullmin, hullmax, mask, ignore. Output Table: pos, fraction, hit, enthit, allsolid, startpos, endpos, startsolid, plane_normal, plane_dist, surface_name, surface_flags, surface_props"
	},
	"float TraceLine(Vector, Vector, handle)": {
		"prefix": "TraceLine",
		"body": [
			"TraceLine(${1:Vector}, ${2:Vector}, ${3:handle})$0"
		],
		"description": "given 2 points & ent to ignore, return fraction along line that hits world or models"
	},
	"bool TraceLineEx(table traceTable)": {
		"prefix": "TraceLineEx",
		"body": [
			"TraceLineEx(${1:table traceTable})$0"
		],
		"description": "Input Table: start, end, mask, ignore. Output Table: pos, fraction, hit, enthit, allsolid, startpos, endpos, startsolid, plane_normal, plane_dist, surface_name, surface_flags, surface_props"
	},
	"float TraceLinePlayersIncluded(Vector, Vector, handle)": {
		"prefix": "TraceLinePlayersIncluded",
		"body": [
			"TraceLinePlayersIncluded(${1:Vector}, ${2:Vector}, ${3:handle})$0"
		],
		"description": "given 2 points & ent to ignore, return fraction along line that hits world, models, players or npcs"
	},
	"bool TryToPickupBuilding()": {
		"prefix": "TryToPickupBuilding",
		"body": [
			"TryToPickupBuilding()$0"
		],
		"description": "Make the player attempt to pick up a building in front of them"
	},
	"void UnblockArea()": {
		"prefix": "UnblockArea",
		"body": [
			"UnblockArea()$0"
		],
		"description": "Unblocks this area"
	},
	"UnhookRootMetamethod()": {
		"prefix": "UnhookRootMetamethod",
		"body": [
			"UnhookRootMetamethod()$0"
		],
		"description": ""
	},
	"string UniqueString(string input)": {
		"prefix": "UniqueString",
		"body": [
			"UniqueString(${1:string input})$0"
		],
		"description": "Generate a string guaranteed to be unique across the life of the script VM, with an optional root string. Useful for adding data to tables when not sure what keys are already in use in that table."
	},
	"void UnregisterAvoidanceObstacle(handle entity)": {
		"prefix": "UnregisterAvoidanceObstacle",
		"body": [
			"UnregisterAvoidanceObstacle(${1:handle entity})$0"
		],
		"description": "unregisters avoidance obstacle"
	},
	"Up()": {
		"prefix": "Up",
		"body": [
			"Up()$0"
		],
		"description": ""
	},
	"void UpdateDelayedThreatNotices()": {
		"prefix": "UpdateDelayedThreatNotices",
		"body": [
			"UpdateDelayedThreatNotices()$0"
		],
		"description": ""
	},
	"bool UsePlayerReadyStatusMode()": {
		"prefix": "UsePlayerReadyStatusMode",
		"body": [
			"UsePlayerReadyStatusMode()$0"
		],
		"description": ""
	},
	"bool UsesClipsForAmmo1()": {
		"prefix": "UsesClipsForAmmo1",
		"body": [
			"UsesClipsForAmmo1()$0"
		],
		"description": "Do we use clips for ammo 1?"
	},
	"bool UsesClipsForAmmo2()": {
		"prefix": "UsesClipsForAmmo2",
		"body": [
			"UsesClipsForAmmo2()$0"
		],
		"description": "Do we use clips for ammo 2?"
	},
	"bool UsesPrimaryAmmo()": {
		"prefix": "UsesPrimaryAmmo",
		"body": [
			"UsesPrimaryAmmo()$0"
		],
		"description": "Do we use primary ammo?"
	},
	"bool UsesSecondaryAmmo()": {
		"prefix": "UsesSecondaryAmmo",
		"body": [
			"UsesSecondaryAmmo()$0"
		],
		"description": "Do we use secondary ammo?"
	},
	"table VSquirrel_OnCreateScope(any value, table scope)": {
		"prefix": "VSquirrel_OnCreateScope",
		"body": [
			"VSquirrel_OnCreateScope(${1:any value}, ${2:table scope})$0"
		],
		"description": "Creates a new scope with the name of value in the submitted table (includes unique params)."
	},
	"void VSquirrel_OnReleaseScope(table createdScope)": {
		"prefix": "VSquirrel_OnReleaseScope",
		"body": [
			"VSquirrel_OnReleaseScope(${1:table createdScope})$0"
		],
		"description": "Removes a scope created via VSquirrel_OnCreateScope."
	},
	"bool ValidateScriptScope()": {
		"prefix": "ValidateScriptScope",
		"body": [
			"ValidateScriptScope()$0"
		],
		"description": "Ensure that an entity's script scope has been created"
	},
	"Vector2D(float, float)": {
		"prefix": "Vector2D",
		"body": [
			"Vector2D(${1:float}, ${2:float})$0"
		],
		"description": "Creates a new 2D vector with the specified Cartesian coordiantes."
	},
	"Vector4D(float, float, float, float)": {
		"prefix": "Vector4D",
		"body": [
			"Vector4D(${1:float}, ${2:float}, ${3:float}, ${4:float})$0"
		],
		"description": "Creates a new 4D vector with the specified Cartesian coordiantes."
	},
	"void ViewPunch(QAngle)": {
		"prefix": "ViewPunch",
		"body": [
			"ViewPunch(${1:QAngle})$0"
		],
		"description": "Ow! Punches the player's view"
	},
	"void ViewPunchReset(float)": {
		"prefix": "ViewPunchReset",
		"body": [
			"ViewPunchReset(${1:float})$0"
		],
		"description": "Reset's the player's view punch"
	},
	"bool VisibleInWeaponSelection()": {
		"prefix": "VisibleInWeaponSelection",
		"body": [
			"VisibleInWeaponSelection()$0"
		],
		"description": "Is this weapon visible in weapon selection"
	},
	"void Walk()": {
		"prefix": "Walk",
		"body": [
			"Walk()$0"
		],
		"description": "Set desired movement speed to walking"
	},
	"bool WasInCond(ETFCond cond)": {
		"prefix": "WasInCond",
		"body": [
			"WasInCond(${1:ETFCond cond})$0"
		],
		"description": ""
	},
	"Yaw()": {
		"prefix": "Yaw",
		"body": [
			"Yaw()$0"
		],
		"description": ""
	},
	"void __CollectEventCallbacks(scope, prefix, globalTableName, regFunc)": {
		"prefix": "__CollectEventCallbacks",
		"body": [
			"__CollectEventCallbacks(${1:scope}, ${2:prefix}, ${3:globalTableName}, ${4:regFunc})$0"
		],
		"description": "Overloaded function. Its only used for this: __CollectEventCallbacks(scope, \"OnGameEvent_\", \"GameEventCallbacks\", ::RegisterScriptGameEventListener)"
	},
	"void __CollectGameEventCallbacks(scope)": {
		"prefix": "__CollectGameEventCallbacks",
		"body": [
			"__CollectGameEventCallbacks(${1:scope})$0"
		],
		"description": "Wrapper that registers callbacks for both OnGameEvent_x and OnScriptEvent_ functions. Done using the __CollectEventCallbacks function."
	},
	"void __DumpScope(int indentation, handle scope)": {
		"prefix": "__DumpScope",
		"body": [
			"__DumpScope(${1:int indentation}, ${2:handle scope})$0"
		],
		"description": "Dumps contents of everything in the scope."
	},
	"__KeyValueFromFloat(string, float)": {
		"prefix": "__KeyValueFromFloat",
		"body": [
			"__KeyValueFromFloat(${1:string}, ${2:float})$0"
		],
		"description": ""
	},
	"__KeyValueFromInt(string, int)": {
		"prefix": "__KeyValueFromInt",
		"body": [
			"__KeyValueFromInt(${1:string}, ${2:int})$0"
		],
		"description": ""
	},
	"__KeyValueFromString(string, string)": {
		"prefix": "__KeyValueFromString",
		"body": [
			"__KeyValueFromString(${1:string}, ${2:string})$0"
		],
		"description": ""
	},
	"__KeyValueFromVector(string, Vector)": {
		"prefix": "__KeyValueFromVector",
		"body": [
			"__KeyValueFromVector(${1:string}, ${2:Vector})$0"
		],
		"description": ""
	},
	"void __ReplaceClosures(script, scope)": {
		"prefix": "__ReplaceClosures",
		"body": [
			"__ReplaceClosures(${1:script}, ${2:scope})$0"
		],
		"description": ""
	},
	"void __RunEventCallbacks(event, params, prefix, globalTableName, bWarnIfMissing)": {
		"prefix": "__RunEventCallbacks",
		"body": [
			"__RunEventCallbacks(${1:event}, ${2:params}, ${3:prefix}, ${4:globalTableName}, ${5:bWarnIfMissing})$0"
		],
		"description": "Call all functions in the callback array for the given game event"
	},
	"void __RunGameEventCallbacks(event, params)": {
		"prefix": "__RunGameEventCallbacks",
		"body": [
			"__RunGameEventCallbacks(${1:event}, ${2:params})$0"
		],
		"description": "Wrapper for __RunEventCallbacks()"
	},
	"void __RunScriptHookCallbacks()": {
		"prefix": "__RunScriptHookCallbacks",
		"body": [
			"__RunScriptHookCallbacks()$0"
		],
		"description": ""
	},
	"__VScriptServerDebugHook()": {
		"prefix": "__VScriptServerDebugHook",
		"body": [
			"__VScriptServerDebugHook()$0"
		],
		"description": ""
	},
	"_charsize_": {
		"prefix": "_charsize_",
		"body": [
			""
		],
		"description": ""
	},
	"_floatsize_": {
		"prefix": "_floatsize_",
		"body": [
			""
		],
		"description": ""
	},
	"_intsize_": {
		"prefix": "_intsize_",
		"body": [
			""
		],
		"description": ""
	},
	"_version_": {
		"prefix": "_version_",
		"body": [
			""
		],
		"description": ""
	},
	"_versionnumber_": {
		"prefix": "_versionnumber_",
		"body": [
			""
		],
		"description": ""
	},
	"abs(num x)": {
		"prefix": "abs",
		"body": [
			"abs(${1:num x})$0"
		],
		"description": "Returns x as integer unlike fabs()"
	},
	"acos(num x)": {
		"prefix": "acos",
		"body": [
			"acos(${1:num x})$0"
		],
		"description": "Returns cos^-1(x), -1 <= x <= 1"
	},
	"array(int length, any fill = null)": {
		"prefix": "array",
		"body": [
			"array(${1:int length}, ${2:any fill = null})$0"
		],
		"description": "Returns a new array of the given length where each element is set to fill (null by default)."
	},
	"asin(num x)": {
		"prefix": "asin",
		"body": [
			"asin(${1:num x})$0"
		],
		"description": "Returns sin^-1(x), -1 <= x <= 1"
	},
	"assert(bool exp)": {
		"prefix": "assert",
		"body": [
			"assert(${1:bool exp})$0"
		],
		"description": "Throws an assertion error if the given expression evaluates to false (i.e. the values 0, 0.0, null and false)"
	},
	"atan(num x)": {
		"prefix": "atan",
		"body": [
			"atan(${1:num x})$0"
		],
		"description": "Returns tan^-1(x)"
	},
	"atan2(num y, num x) (!)": {
		"prefix": "atan2",
		"body": [
			"atan2(${1:num y}, ${2:num x) (!})$0"
		],
		"description": "Returns the angle between the ray from the point (0, 0) through (x, y) and the positive x-axis, confined to (PI, PI]. Note the order of the parameters x and y!"
	},
	"function callee()": {
		"prefix": "callee",
		"body": [
			"callee()$0"
		],
		"description": "Returns the currently running closure."
	},
	"table capture(str, start)": {
		"prefix": "capture",
		"body": [
			"capture(${1:str}, ${2:start})$0"
		],
		"description": "Returns an array of tables containing two indexes (\"begin\" and \"end\") of the first match of the regular expression in the string str. An array entry is created for each captured sub expressions. If no match occurs returns null. The search starts from the index start of the string, if start is omitted the search starts from the beginning of the string."
	},
	"ceil(num x)": {
		"prefix": "ceil",
		"body": [
			"ceil(${1:num x})$0"
		],
		"description": "Returns the smallest integer that is >= x"
	},
	"chain()": {
		"prefix": "chain",
		"body": [
			"chain()$0"
		],
		"description": ""
	},
	"chains()": {
		"prefix": "chains",
		"body": [
			"chains()$0"
		],
		"description": ""
	},
	"int collectgarbage()": {
		"prefix": "collectgarbage",
		"body": [
			"collectgarbage()$0"
		],
		"description": "Runs the garbage collector and returns the number of reference cycles found(and deleted) This function only works on garbage collector builds."
	},
	"any compilestring(string string, string buffername = null)": {
		"prefix": "compilestring",
		"body": [
			"compilestring(${1:string string}, ${2:string buffername = null})$0"
		],
		"description": "Compiles a string containing a squirrel script into a function and returns it."
	},
	"constructor()": {
		"prefix": "constructor",
		"body": [
			"constructor()$0"
		],
		"description": ""
	},
	"cos(num x)": {
		"prefix": "cos",
		"body": [
			"cos(${1:num x})$0"
		],
		"description": "Returns cos(x)"
	},
	"int developer()": {
		"prefix": "developer",
		"body": [
			"developer()$0"
		],
		"description": "The current level of the developer console variable."
	},
	"dummy()": {
		"prefix": "dummy",
		"body": [
			"dummy()$0"
		],
		"description": ""
	},
	"void enabledebuginfo(any enable)": {
		"prefix": "enabledebuginfo",
		"body": [
			"enabledebuginfo(${1:any enable})$0"
		],
		"description": "Enable/disable the debug line information generation at compile time. enable != null enables . enable == null disables."
	},
	"int entindex()": {
		"prefix": "entindex",
		"body": [
			"entindex()$0"
		],
		"description": ""
	},
	"void error(string x)": {
		"prefix": "error",
		"body": [
			"error(${1:string x})$0"
		],
		"description": "Prints x in the standard error output ."
	},
	"exp(num x)": {
		"prefix": "exp",
		"body": [
			"exp(${1:num x})$0"
		],
		"description": "Returns exp(x) = e^x"
	},
	"fabs(num x)": {
		"prefix": "fabs",
		"body": [
			"fabs(${1:num x})$0"
		],
		"description": "Returns x as float unlike abs()"
	},
	"floor(num x)": {
		"prefix": "floor",
		"body": [
			"floor(${1:num x})$0"
		],
		"description": "Returns the largest integer that is x"
	},
	"format(string, args...)": {
		"prefix": "format",
		"body": [
			"format(${1:string}, ${2:args...})$0"
		],
		"description": "Returns a formatted string"
	},
	"table getconsttable()": {
		"prefix": "getconsttable",
		"body": [
			"getconsttable()$0"
		],
		"description": "Returns the const table of the VM."
	},
	"table getroottable()": {
		"prefix": "getroottable",
		"body": [
			"getroottable()$0"
		],
		"description": "Returns the root table of the VM."
	},
	"table getstackinfos(int stacklevel)": {
		"prefix": "getstackinfos",
		"body": [
			"getstackinfos(${1:int stacklevel})$0"
		],
		"description": "Returns the stack frame informations at the given stack level (0 is the current function 1 is the caller and so on). If the stack level doesn't exist the function returns null."
	},
	"log(num x)": {
		"prefix": "log",
		"body": [
			"log(${1:num x})$0"
		],
		"description": "Returns log_e(x) = ln(x)"
	},
	"log10(num x)": {
		"prefix": "log10",
		"body": [
			"log10(${1:num x})$0"
		],
		"description": "Returns log_10(x)"
	},
	"lstrip(string)": {
		"prefix": "lstrip",
		"body": [
			"lstrip(${1:string})$0"
		],
		"description": "Removes whitespace at the beginning of the given string"
	},
	"m_bindNamesStack()": {
		"prefix": "m_bindNamesStack",
		"body": [
			"m_bindNamesStack()$0"
		],
		"description": ""
	},
	"m_fixupSet()": {
		"prefix": "m_fixupSet",
		"body": [
			"m_fixupSet()$0"
		],
		"description": ""
	},
	"m_targetTable()": {
		"prefix": "m_targetTable",
		"body": [
			"m_targetTable()$0"
		],
		"description": ""
	},
	"bool match(str)": {
		"prefix": "match",
		"body": [
			"match(${1:str})$0"
		],
		"description": "Returns a true if the regular expression matches the string str, otherwise returns false."
	},
	"coroutine newthread(function threadfunc)": {
		"prefix": "newthread",
		"body": [
			"newthread(${1:function threadfunc})$0"
		],
		"description": "Creates a new cooperative thread object(coroutine) and returns it ."
	},
	"pow(num x, num y)": {
		"prefix": "pow",
		"body": [
			"pow(${1:num x}, ${2:num y})$0"
		],
		"description": "Returns x_y"
	},
	"prefix()": {
		"prefix": "prefix",
		"body": [
			"prefix()$0"
		],
		"description": ""
	},
	"print(string message)": {
		"prefix": "print",
		"body": [
			"print(${1:string message})$0"
		],
		"description": "Prints the given parameter but with no newline unlike printl()"
	},
	"void printl(string message)": {
		"prefix": "printl",
		"body": [
			"printl(${1:string message})$0"
		],
		"description": "Prints message to console with a line feed after."
	},
	"rand()": {
		"prefix": "rand",
		"body": [
			"rand()$0"
		],
		"description": "Returns a random integer with 0 <= rand() <= RAND_MAX"
	},
	"void realPrint(string message)": {
		"prefix": "realPrint",
		"body": [
			"realPrint(${1:string message})$0"
		],
		"description": "Identical to print. print seems to be a wrapper for this."
	},
	"regexp()": {
		"prefix": "regexp",
		"body": [
			"regexp()$0"
		],
		"description": ""
	},
	"array resurrectunreachable()": {
		"prefix": "resurrectunreachable",
		"body": [
			"resurrectunreachable()$0"
		],
		"description": "Runs the garbage collector and returns an array containing all unreachable object found. If no unreachable object is found, null is returned instead. This function is meant to help debugging reference cycles. This function only works on garbage collector builds."
	},
	"rstrip(string)": {
		"prefix": "rstrip",
		"body": [
			"rstrip(${1:string})$0"
		],
		"description": "Removes whitespace at the end of the given string"
	},
	"scope()": {
		"prefix": "scope",
		"body": [
			"scope()$0"
		],
		"description": ""
	},
	"table search(str, start)": {
		"prefix": "search",
		"body": [
			"search(${1:str}, ${2:start})$0"
		],
		"description": "Returns a table containing two indexes (\"begin\" and \"end\") of the first match of the regular expression in the string st, otherwise if no match occurs returns null. The search starts from the index start of the string, if start is omitted the search starts from the beginning of the string."
	},
	"table setconsttable(table consttable)": {
		"prefix": "setconsttable",
		"body": [
			"setconsttable(${1:table consttable})$0"
		],
		"description": "Sets the const table of the VM which also returns the previous const table."
	},
	"void setdebughook(function hook_func)": {
		"prefix": "setdebughook",
		"body": [
			"setdebughook(${1:function hook_func})$0"
		],
		"description": "Sets the debug hook."
	},
	"void seterrorhandler(function func)": {
		"prefix": "seterrorhandler",
		"body": [
			"seterrorhandler(${1:function func})$0"
		],
		"description": "Sets the runtime error handler ."
	},
	"table setroottable(table roottable)": {
		"prefix": "setroottable",
		"body": [
			"setroottable(${1:table roottable})$0"
		],
		"description": "Sets the root table of the VM which also returns the previous root table."
	},
	"sin(num x)": {
		"prefix": "sin",
		"body": [
			"sin(${1:num x})$0"
		],
		"description": "Returns sin(x)"
	},
	"string split(string str, string separator')": {
		"prefix": "split",
		"body": [
			"split(${1:string str}, ${2:string separator'})$0"
		],
		"description": "Returns an array of strings split at each point where a separator character occurs in str. The separator is not returned as part of any array element. the parameter separators is a string that specifies the characters as to be used for the splitting."
	},
	"sqrt(num x)": {
		"prefix": "sqrt",
		"body": [
			"sqrt(${1:num x})$0"
		],
		"description": "Returns the square root of x"
	},
	"srand(num seed)": {
		"prefix": "srand",
		"body": [
			"srand(${1:num seed})$0"
		],
		"description": "Sets the starting point for generating a series of pseudorandom integers"
	},
	"strip(string)": {
		"prefix": "strip",
		"body": [
			"strip(${1:string})$0"
		],
		"description": "Removes whitespace at the beginning and end of the given string"
	},
	"subexpcount()": {
		"prefix": "subexpcount",
		"body": [
			"subexpcount()$0"
		],
		"description": ""
	},
	"void suspend(any ret)": {
		"prefix": "suspend",
		"body": [
			"suspend(${1:any ret})$0"
		],
		"description": "Suspends the coroutine that called this function."
	},
	"tan(num x)": {
		"prefix": "tan",
		"body": [
			"tan(${1:num x})$0"
		],
		"description": "Returns tan(x)"
	},
	"string tostring()": {
		"prefix": "tostring",
		"body": [
			"tostring()$0"
		],
		"description": "Returns a human-readable string."
	},
	"type(var)": {
		"prefix": "type",
		"body": [
			"type(${1:var})$0"
		],
		"description": "Returns var._typeof(), i.e. the type of the given parameter as a string"
	}
	///// END TF2 VScript Snippets /////
}